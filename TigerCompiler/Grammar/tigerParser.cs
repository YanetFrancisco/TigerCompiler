//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g 2014-04-27 15:21:32

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019

 
    using System;


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace  TigerCompiler.Grammar 
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class tigerParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "AACCESS", "ACCESS", "AND", "ARRAY", "ARRAYDEC", "ARRAYTYPE", "ASSIGN", "BACK_SLASH", "BINARYDIGIT", "BREAK", "CALL", "CBRACK", "CKEYS", "COLON", "COMMA", "COMMENT", "CPAR", "DECLIST", "DIGIT", "DIV", "DO", "DOT", "DOUBLE_QUOTE", "ELSE", "END", "EQ", "ESC_SEQ", "EXPLIST", "EXPSEQ", "FIELD", "FIELDLIST", "FOR", "FUNC", "FUNCBLOCK", "FUNCDEC", "GT", "GTEQ", "HALFOFBYTE", "ID", "IDACCESS", "IF", "IN", "INT", "LET", "LT", "LTEQ", "MINUS", "MULT", "NEG", "NIL", "NOTEQ", "OBRACK", "OCTAL", "OF", "OKEYS", "OPAR", "OR", "PLUS", "PRINTABLECHAR", "PRINT_CHAR", "PROC", "RECORDDEC", "RECORDTYPE", "SMCOL", "STRING", "THEN", "TO", "TYPE", "TYPEBLOCK", "TYPEDEC", "TYPEFIELD", "TYPEFIELDS", "TYPETOK", "VALUE", "VAR", "VARBLOCK", "WHILE", "WS"
	};
	public const int EOF=-1;
	public const int AACCESS=4;
	public const int ACCESS=5;
	public const int AND=6;
	public const int ARRAY=7;
	public const int ARRAYDEC=8;
	public const int ARRAYTYPE=9;
	public const int ASSIGN=10;
	public const int BACK_SLASH=11;
	public const int BINARYDIGIT=12;
	public const int BREAK=13;
	public const int CALL=14;
	public const int CBRACK=15;
	public const int CKEYS=16;
	public const int COLON=17;
	public const int COMMA=18;
	public const int COMMENT=19;
	public const int CPAR=20;
	public const int DECLIST=21;
	public const int DIGIT=22;
	public const int DIV=23;
	public const int DO=24;
	public const int DOT=25;
	public const int DOUBLE_QUOTE=26;
	public const int ELSE=27;
	public const int END=28;
	public const int EQ=29;
	public const int ESC_SEQ=30;
	public const int EXPLIST=31;
	public const int EXPSEQ=32;
	public const int FIELD=33;
	public const int FIELDLIST=34;
	public const int FOR=35;
	public const int FUNC=36;
	public const int FUNCBLOCK=37;
	public const int FUNCDEC=38;
	public const int GT=39;
	public const int GTEQ=40;
	public const int HALFOFBYTE=41;
	public const int ID=42;
	public const int IDACCESS=43;
	public const int IF=44;
	public const int IN=45;
	public const int INT=46;
	public const int LET=47;
	public const int LT=48;
	public const int LTEQ=49;
	public const int MINUS=50;
	public const int MULT=51;
	public const int NEG=52;
	public const int NIL=53;
	public const int NOTEQ=54;
	public const int OBRACK=55;
	public const int OCTAL=56;
	public const int OF=57;
	public const int OKEYS=58;
	public const int OPAR=59;
	public const int OR=60;
	public const int PLUS=61;
	public const int PRINTABLECHAR=62;
	public const int PRINT_CHAR=63;
	public const int PROC=64;
	public const int RECORDDEC=65;
	public const int RECORDTYPE=66;
	public const int SMCOL=67;
	public const int STRING=68;
	public const int THEN=69;
	public const int TO=70;
	public const int TYPE=71;
	public const int TYPEBLOCK=72;
	public const int TYPEDEC=73;
	public const int TYPEFIELD=74;
	public const int TYPEFIELDS=75;
	public const int TYPETOK=76;
	public const int VALUE=77;
	public const int VAR=78;
	public const int VARBLOCK=79;
	public const int WHILE=80;
	public const int WS=81;

	 public  tigerParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	 public  tigerParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return tigerParser.tokenNames; } }
	public override string GrammarFileName { get { return "C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_program();
	partial void LeaveRule_program();

	// $ANTLR start "program"
	// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:152:8: public program : exp EOF !;
	[GrammarRule("program")]
	public AstParserRuleReturnScope<object, IToken> program()
	{
		EnterRule_program();
		EnterRule("program", 1);
		TraceIn("program", 1);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken EOF2 = default(IToken);
		AstParserRuleReturnScope<object, IToken> exp1 = default(AstParserRuleReturnScope<object, IToken>);

		object EOF2_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "program");
		DebugLocation(152, 24);
		try
		{
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:152:15: ( exp EOF !)
			DebugEnterAlt(1);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:152:17: exp EOF !
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(152, 17);
			PushFollow(Follow._exp_in_program809);
			exp1=exp();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, exp1.Tree);
			DebugLocation(152, 24);
			EOF2=(IToken)Match(input,EOF,Follow._EOF_in_program811); if (state.failed) return retval;

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("program", 1);
			LeaveRule("program", 1);
			LeaveRule_program();
		}
		DebugLocation(152, 24);
		} finally { DebugExitRule(GrammarFileName, "program"); }
		return retval;

	}
	// $ANTLR end "program"

	partial void EnterRule_exp();
	partial void LeaveRule_exp();

	// $ANTLR start "exp"
	// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:154:1: exp : auxOR ( OR ^ auxOR )* ;
	[GrammarRule("exp")]
	private AstParserRuleReturnScope<object, IToken> exp()
	{
		EnterRule_exp();
		EnterRule("exp", 2);
		TraceIn("exp", 2);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken OR4 = default(IToken);
		AstParserRuleReturnScope<object, IToken> auxOR3 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> auxOR5 = default(AstParserRuleReturnScope<object, IToken>);

		object OR4_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "exp");
		DebugLocation(154, 29);
		try
		{
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:154:4: ( auxOR ( OR ^ auxOR )* )
			DebugEnterAlt(1);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:154:7: auxOR ( OR ^ auxOR )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(154, 7);
			PushFollow(Follow._auxOR_in_exp820);
			auxOR3=auxOR();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, auxOR3.Tree);
			DebugLocation(154, 14);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:154:14: ( OR ^ auxOR )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_0 = input.LA(1);

				if ((LA1_0==OR))
				{
					int LA1_2 = input.LA(2);

					if ((EvaluatePredicate(synpred1_tiger_fragment)))
					{
						alt1 = 1;
					}


				}


				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:154:15: OR ^ auxOR
					{
					DebugLocation(154, 17);
					OR4=(IToken)Match(input,OR,Follow._OR_in_exp824); if (state.failed) return retval;
					if (state.backtracking == 0) {
					OR4_tree = (object)adaptor.Create(OR4);
					root_0 = (object)adaptor.BecomeRoot(OR4_tree, root_0);
					}
					DebugLocation(154, 20);
					PushFollow(Follow._auxOR_in_exp828);
					auxOR5=auxOR();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, auxOR5.Tree);

					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("exp", 2);
			LeaveRule("exp", 2);
			LeaveRule_exp();
		}
		DebugLocation(154, 29);
		} finally { DebugExitRule(GrammarFileName, "exp"); }
		return retval;

	}
	// $ANTLR end "exp"

	partial void EnterRule_auxOR();
	partial void LeaveRule_auxOR();

	// $ANTLR start "auxOR"
	// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:156:1: auxOR : auxAND ( AND ^ auxAND )* ;
	[GrammarRule("auxOR")]
	private AstParserRuleReturnScope<object, IToken> auxOR()
	{
		EnterRule_auxOR();
		EnterRule("auxOR", 3);
		TraceIn("auxOR", 3);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken AND7 = default(IToken);
		AstParserRuleReturnScope<object, IToken> auxAND6 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> auxAND8 = default(AstParserRuleReturnScope<object, IToken>);

		object AND7_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "auxOR");
		DebugLocation(156, 30);
		try
		{
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:156:6: ( auxAND ( AND ^ auxAND )* )
			DebugEnterAlt(1);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:156:9: auxAND ( AND ^ auxAND )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(156, 9);
			PushFollow(Follow._auxAND_in_auxOR841);
			auxAND6=auxAND();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, auxAND6.Tree);
			DebugLocation(156, 16);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:156:16: ( AND ^ auxAND )*
			try { DebugEnterSubRule(2);
			while (true)
			{
				int alt2=2;
				try { DebugEnterDecision(2, false);
				int LA2_0 = input.LA(1);

				if ((LA2_0==AND))
				{
					int LA2_2 = input.LA(2);

					if ((EvaluatePredicate(synpred2_tiger_fragment)))
					{
						alt2 = 1;
					}


				}


				} finally { DebugExitDecision(2); }
				switch ( alt2 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:156:17: AND ^ auxAND
					{
					DebugLocation(156, 20);
					AND7=(IToken)Match(input,AND,Follow._AND_in_auxOR844); if (state.failed) return retval;
					if (state.backtracking == 0) {
					AND7_tree = (object)adaptor.Create(AND7);
					root_0 = (object)adaptor.BecomeRoot(AND7_tree, root_0);
					}
					DebugLocation(156, 22);
					PushFollow(Follow._auxAND_in_auxOR847);
					auxAND8=auxAND();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, auxAND8.Tree);

					}
					break;

				default:
					goto loop2;
				}
			}

			loop2:
				;

			} finally { DebugExitSubRule(2); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("auxOR", 3);
			LeaveRule("auxOR", 3);
			LeaveRule_auxOR();
		}
		DebugLocation(156, 30);
		} finally { DebugExitRule(GrammarFileName, "auxOR"); }
		return retval;

	}
	// $ANTLR end "auxOR"

	partial void EnterRule_auxAND();
	partial void LeaveRule_auxAND();

	// $ANTLR start "auxAND"
	// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:158:1: auxAND : auxPM ( ( EQ ^ auxPM ) | ( NOTEQ ^ auxPM ) | ( LTEQ ^ auxPM ) | ( GTEQ ^ auxPM ) | ( LT ^ auxPM ) | ( GT ^ auxPM ) )? ;
	[GrammarRule("auxAND")]
	private AstParserRuleReturnScope<object, IToken> auxAND()
	{
		EnterRule_auxAND();
		EnterRule("auxAND", 4);
		TraceIn("auxAND", 4);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken EQ10 = default(IToken);
		IToken NOTEQ12 = default(IToken);
		IToken LTEQ14 = default(IToken);
		IToken GTEQ16 = default(IToken);
		IToken LT18 = default(IToken);
		IToken GT20 = default(IToken);
		AstParserRuleReturnScope<object, IToken> auxPM9 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> auxPM11 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> auxPM13 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> auxPM15 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> auxPM17 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> auxPM19 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> auxPM21 = default(AstParserRuleReturnScope<object, IToken>);

		object EQ10_tree = default(object);
		object NOTEQ12_tree = default(object);
		object LTEQ14_tree = default(object);
		object GTEQ16_tree = default(object);
		object LT18_tree = default(object);
		object GT20_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "auxAND");
		DebugLocation(158, 107);
		try
		{
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:158:7: ( auxPM ( ( EQ ^ auxPM ) | ( NOTEQ ^ auxPM ) | ( LTEQ ^ auxPM ) | ( GTEQ ^ auxPM ) | ( LT ^ auxPM ) | ( GT ^ auxPM ) )? )
			DebugEnterAlt(1);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:158:10: auxPM ( ( EQ ^ auxPM ) | ( NOTEQ ^ auxPM ) | ( LTEQ ^ auxPM ) | ( GTEQ ^ auxPM ) | ( LT ^ auxPM ) | ( GT ^ auxPM ) )?
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(158, 10);
			PushFollow(Follow._auxPM_in_auxAND858);
			auxPM9=auxPM();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, auxPM9.Tree);
			DebugLocation(158, 16);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:158:16: ( ( EQ ^ auxPM ) | ( NOTEQ ^ auxPM ) | ( LTEQ ^ auxPM ) | ( GTEQ ^ auxPM ) | ( LT ^ auxPM ) | ( GT ^ auxPM ) )?
			int alt3=7;
			try { DebugEnterSubRule(3);
			try { DebugEnterDecision(3, false);
			switch (input.LA(1))
			{
			case EQ:
				{
				int LA3_1 = input.LA(2);

				if ((EvaluatePredicate(synpred3_tiger_fragment)))
				{
					alt3 = 1;
				}
				}
				break;
			case NOTEQ:
				{
				int LA3_2 = input.LA(2);

				if ((EvaluatePredicate(synpred4_tiger_fragment)))
				{
					alt3 = 2;
				}
				}
				break;
			case LTEQ:
				{
				int LA3_3 = input.LA(2);

				if ((EvaluatePredicate(synpred5_tiger_fragment)))
				{
					alt3 = 3;
				}
				}
				break;
			case GTEQ:
				{
				int LA3_4 = input.LA(2);

				if ((EvaluatePredicate(synpred6_tiger_fragment)))
				{
					alt3 = 4;
				}
				}
				break;
			case LT:
				{
				int LA3_5 = input.LA(2);

				if ((EvaluatePredicate(synpred7_tiger_fragment)))
				{
					alt3 = 5;
				}
				}
				break;
			case GT:
				{
				int LA3_6 = input.LA(2);

				if ((EvaluatePredicate(synpred8_tiger_fragment)))
				{
					alt3 = 6;
				}
				}
				break;
			}

			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:158:17: ( EQ ^ auxPM )
				{
				DebugLocation(158, 17);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:158:17: ( EQ ^ auxPM )
				DebugEnterAlt(1);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:158:18: EQ ^ auxPM
				{
				DebugLocation(158, 20);
				EQ10=(IToken)Match(input,EQ,Follow._EQ_in_auxAND862); if (state.failed) return retval;
				if (state.backtracking == 0) {
				EQ10_tree = (object)adaptor.Create(EQ10);
				root_0 = (object)adaptor.BecomeRoot(EQ10_tree, root_0);
				}
				DebugLocation(158, 22);
				PushFollow(Follow._auxPM_in_auxAND865);
				auxPM11=auxPM();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, auxPM11.Tree);

				}


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:158:31: ( NOTEQ ^ auxPM )
				{
				DebugLocation(158, 31);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:158:31: ( NOTEQ ^ auxPM )
				DebugEnterAlt(1);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:158:32: NOTEQ ^ auxPM
				{
				DebugLocation(158, 37);
				NOTEQ12=(IToken)Match(input,NOTEQ,Follow._NOTEQ_in_auxAND871); if (state.failed) return retval;
				if (state.backtracking == 0) {
				NOTEQ12_tree = (object)adaptor.Create(NOTEQ12);
				root_0 = (object)adaptor.BecomeRoot(NOTEQ12_tree, root_0);
				}
				DebugLocation(158, 39);
				PushFollow(Follow._auxPM_in_auxAND874);
				auxPM13=auxPM();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, auxPM13.Tree);

				}


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:158:48: ( LTEQ ^ auxPM )
				{
				DebugLocation(158, 48);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:158:48: ( LTEQ ^ auxPM )
				DebugEnterAlt(1);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:158:49: LTEQ ^ auxPM
				{
				DebugLocation(158, 53);
				LTEQ14=(IToken)Match(input,LTEQ,Follow._LTEQ_in_auxAND880); if (state.failed) return retval;
				if (state.backtracking == 0) {
				LTEQ14_tree = (object)adaptor.Create(LTEQ14);
				root_0 = (object)adaptor.BecomeRoot(LTEQ14_tree, root_0);
				}
				DebugLocation(158, 55);
				PushFollow(Follow._auxPM_in_auxAND883);
				auxPM15=auxPM();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, auxPM15.Tree);

				}


				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:158:64: ( GTEQ ^ auxPM )
				{
				DebugLocation(158, 64);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:158:64: ( GTEQ ^ auxPM )
				DebugEnterAlt(1);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:158:65: GTEQ ^ auxPM
				{
				DebugLocation(158, 69);
				GTEQ16=(IToken)Match(input,GTEQ,Follow._GTEQ_in_auxAND889); if (state.failed) return retval;
				if (state.backtracking == 0) {
				GTEQ16_tree = (object)adaptor.Create(GTEQ16);
				root_0 = (object)adaptor.BecomeRoot(GTEQ16_tree, root_0);
				}
				DebugLocation(158, 71);
				PushFollow(Follow._auxPM_in_auxAND892);
				auxPM17=auxPM();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, auxPM17.Tree);

				}


				}
				break;
			case 5:
				DebugEnterAlt(5);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:158:80: ( LT ^ auxPM )
				{
				DebugLocation(158, 80);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:158:80: ( LT ^ auxPM )
				DebugEnterAlt(1);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:158:81: LT ^ auxPM
				{
				DebugLocation(158, 83);
				LT18=(IToken)Match(input,LT,Follow._LT_in_auxAND898); if (state.failed) return retval;
				if (state.backtracking == 0) {
				LT18_tree = (object)adaptor.Create(LT18);
				root_0 = (object)adaptor.BecomeRoot(LT18_tree, root_0);
				}
				DebugLocation(158, 85);
				PushFollow(Follow._auxPM_in_auxAND901);
				auxPM19=auxPM();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, auxPM19.Tree);

				}


				}
				break;
			case 6:
				DebugEnterAlt(6);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:158:94: ( GT ^ auxPM )
				{
				DebugLocation(158, 94);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:158:94: ( GT ^ auxPM )
				DebugEnterAlt(1);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:158:95: GT ^ auxPM
				{
				DebugLocation(158, 97);
				GT20=(IToken)Match(input,GT,Follow._GT_in_auxAND907); if (state.failed) return retval;
				if (state.backtracking == 0) {
				GT20_tree = (object)adaptor.Create(GT20);
				root_0 = (object)adaptor.BecomeRoot(GT20_tree, root_0);
				}
				DebugLocation(158, 99);
				PushFollow(Follow._auxPM_in_auxAND910);
				auxPM21=auxPM();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, auxPM21.Tree);

				}


				}
				break;

			}
			} finally { DebugExitSubRule(3); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("auxAND", 4);
			LeaveRule("auxAND", 4);
			LeaveRule_auxAND();
		}
		DebugLocation(158, 107);
		} finally { DebugExitRule(GrammarFileName, "auxAND"); }
		return retval;

	}
	// $ANTLR end "auxAND"

	partial void EnterRule_auxPM();
	partial void LeaveRule_auxPM();

	// $ANTLR start "auxPM"
	// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:160:1: auxPM : auxMD ( ( PLUS ^ auxMD ) | ( MINUS ^ auxMD ) )* ;
	[GrammarRule("auxPM")]
	private AstParserRuleReturnScope<object, IToken> auxPM()
	{
		EnterRule_auxPM();
		EnterRule("auxPM", 5);
		TraceIn("auxPM", 5);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken PLUS23 = default(IToken);
		IToken MINUS25 = default(IToken);
		AstParserRuleReturnScope<object, IToken> auxMD22 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> auxMD24 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> auxMD26 = default(AstParserRuleReturnScope<object, IToken>);

		object PLUS23_tree = default(object);
		object MINUS25_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "auxPM");
		DebugLocation(160, 47);
		try
		{
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:160:6: ( auxMD ( ( PLUS ^ auxMD ) | ( MINUS ^ auxMD ) )* )
			DebugEnterAlt(1);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:160:9: auxMD ( ( PLUS ^ auxMD ) | ( MINUS ^ auxMD ) )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(160, 9);
			PushFollow(Follow._auxMD_in_auxPM922);
			auxMD22=auxMD();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, auxMD22.Tree);
			DebugLocation(160, 15);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:160:15: ( ( PLUS ^ auxMD ) | ( MINUS ^ auxMD ) )*
			try { DebugEnterSubRule(4);
			while (true)
			{
				int alt4=3;
				try { DebugEnterDecision(4, false);
				int LA4_0 = input.LA(1);

				if ((LA4_0==PLUS))
				{
					int LA4_2 = input.LA(2);

					if ((EvaluatePredicate(synpred9_tiger_fragment)))
					{
						alt4 = 1;
					}


				}
				else if ((LA4_0==MINUS))
				{
					int LA4_3 = input.LA(2);

					if ((EvaluatePredicate(synpred10_tiger_fragment)))
					{
						alt4 = 2;
					}


				}


				} finally { DebugExitDecision(4); }
				switch ( alt4 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:160:16: ( PLUS ^ auxMD )
					{
					DebugLocation(160, 16);
					// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:160:16: ( PLUS ^ auxMD )
					DebugEnterAlt(1);
					// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:160:17: PLUS ^ auxMD
					{
					DebugLocation(160, 21);
					PLUS23=(IToken)Match(input,PLUS,Follow._PLUS_in_auxPM926); if (state.failed) return retval;
					if (state.backtracking == 0) {
					PLUS23_tree = (object)adaptor.Create(PLUS23);
					root_0 = (object)adaptor.BecomeRoot(PLUS23_tree, root_0);
					}
					DebugLocation(160, 23);
					PushFollow(Follow._auxMD_in_auxPM929);
					auxMD24=auxMD();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, auxMD24.Tree);

					}


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:160:32: ( MINUS ^ auxMD )
					{
					DebugLocation(160, 32);
					// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:160:32: ( MINUS ^ auxMD )
					DebugEnterAlt(1);
					// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:160:33: MINUS ^ auxMD
					{
					DebugLocation(160, 38);
					MINUS25=(IToken)Match(input,MINUS,Follow._MINUS_in_auxPM935); if (state.failed) return retval;
					if (state.backtracking == 0) {
					MINUS25_tree = (object)adaptor.Create(MINUS25);
					root_0 = (object)adaptor.BecomeRoot(MINUS25_tree, root_0);
					}
					DebugLocation(160, 40);
					PushFollow(Follow._auxMD_in_auxPM938);
					auxMD26=auxMD();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, auxMD26.Tree);

					}


					}
					break;

				default:
					goto loop4;
				}
			}

			loop4:
				;

			} finally { DebugExitSubRule(4); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("auxPM", 5);
			LeaveRule("auxPM", 5);
			LeaveRule_auxPM();
		}
		DebugLocation(160, 47);
		} finally { DebugExitRule(GrammarFileName, "auxPM"); }
		return retval;

	}
	// $ANTLR end "auxPM"

	partial void EnterRule_auxMD();
	partial void LeaveRule_auxMD();

	// $ANTLR start "auxMD"
	// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:162:1: auxMD : auxEXP ( ( MULT ^ auxEXP ) | ( DIV ^ auxEXP ) )* ;
	[GrammarRule("auxMD")]
	private AstParserRuleReturnScope<object, IToken> auxMD()
	{
		EnterRule_auxMD();
		EnterRule("auxMD", 6);
		TraceIn("auxMD", 6);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken MULT28 = default(IToken);
		IToken DIV30 = default(IToken);
		AstParserRuleReturnScope<object, IToken> auxEXP27 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> auxEXP29 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> auxEXP31 = default(AstParserRuleReturnScope<object, IToken>);

		object MULT28_tree = default(object);
		object DIV30_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "auxMD");
		DebugLocation(162, 48);
		try
		{
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:162:6: ( auxEXP ( ( MULT ^ auxEXP ) | ( DIV ^ auxEXP ) )* )
			DebugEnterAlt(1);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:162:9: auxEXP ( ( MULT ^ auxEXP ) | ( DIV ^ auxEXP ) )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(162, 9);
			PushFollow(Follow._auxEXP_in_auxMD949);
			auxEXP27=auxEXP();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, auxEXP27.Tree);
			DebugLocation(162, 16);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:162:16: ( ( MULT ^ auxEXP ) | ( DIV ^ auxEXP ) )*
			try { DebugEnterSubRule(5);
			while (true)
			{
				int alt5=3;
				try { DebugEnterDecision(5, false);
				int LA5_0 = input.LA(1);

				if ((LA5_0==MULT))
				{
					int LA5_2 = input.LA(2);

					if ((EvaluatePredicate(synpred11_tiger_fragment)))
					{
						alt5 = 1;
					}


				}
				else if ((LA5_0==DIV))
				{
					int LA5_3 = input.LA(2);

					if ((EvaluatePredicate(synpred12_tiger_fragment)))
					{
						alt5 = 2;
					}


				}


				} finally { DebugExitDecision(5); }
				switch ( alt5 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:162:17: ( MULT ^ auxEXP )
					{
					DebugLocation(162, 17);
					// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:162:17: ( MULT ^ auxEXP )
					DebugEnterAlt(1);
					// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:162:18: MULT ^ auxEXP
					{
					DebugLocation(162, 22);
					MULT28=(IToken)Match(input,MULT,Follow._MULT_in_auxMD953); if (state.failed) return retval;
					if (state.backtracking == 0) {
					MULT28_tree = (object)adaptor.Create(MULT28);
					root_0 = (object)adaptor.BecomeRoot(MULT28_tree, root_0);
					}
					DebugLocation(162, 24);
					PushFollow(Follow._auxEXP_in_auxMD956);
					auxEXP29=auxEXP();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, auxEXP29.Tree);

					}


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:162:34: ( DIV ^ auxEXP )
					{
					DebugLocation(162, 34);
					// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:162:34: ( DIV ^ auxEXP )
					DebugEnterAlt(1);
					// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:162:35: DIV ^ auxEXP
					{
					DebugLocation(162, 38);
					DIV30=(IToken)Match(input,DIV,Follow._DIV_in_auxMD962); if (state.failed) return retval;
					if (state.backtracking == 0) {
					DIV30_tree = (object)adaptor.Create(DIV30);
					root_0 = (object)adaptor.BecomeRoot(DIV30_tree, root_0);
					}
					DebugLocation(162, 40);
					PushFollow(Follow._auxEXP_in_auxMD965);
					auxEXP31=auxEXP();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, auxEXP31.Tree);

					}


					}
					break;

				default:
					goto loop5;
				}
			}

			loop5:
				;

			} finally { DebugExitSubRule(5); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("auxMD", 6);
			LeaveRule("auxMD", 6);
			LeaveRule_auxMD();
		}
		DebugLocation(162, 48);
		} finally { DebugExitRule(GrammarFileName, "auxMD"); }
		return retval;

	}
	// $ANTLR end "auxMD"

	partial void EnterRule_auxEXP();
	partial void LeaveRule_auxEXP();

	// $ANTLR start "auxEXP"
	// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:164:1: auxEXP : ( STRING -> STRING | MINUS auxEXP -> ^( NEG auxEXP ) | INT -> INT | NIL -> NIL | BREAK -> BREAK | ID ( right )? -> ^( VALUE ID ( right )? ) | ifthen -> ifthen | while -> while | for -> for | let -> let | OPAR ( expseq )? CPAR -> ^( EXPSEQ ( expseq )? ) );
	[GrammarRule("auxEXP")]
	private AstParserRuleReturnScope<object, IToken> auxEXP()
	{
		EnterRule_auxEXP();
		EnterRule("auxEXP", 7);
		TraceIn("auxEXP", 7);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken STRING32 = default(IToken);
		IToken MINUS33 = default(IToken);
		IToken INT35 = default(IToken);
		IToken NIL36 = default(IToken);
		IToken BREAK37 = default(IToken);
		IToken ID38 = default(IToken);
		IToken OPAR44 = default(IToken);
		IToken CPAR46 = default(IToken);
		AstParserRuleReturnScope<object, IToken> auxEXP34 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> right39 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> ifthen40 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> while41 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> for42 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> let43 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expseq45 = default(AstParserRuleReturnScope<object, IToken>);

		object STRING32_tree = default(object);
		object MINUS33_tree = default(object);
		object INT35_tree = default(object);
		object NIL36_tree = default(object);
		object BREAK37_tree = default(object);
		object ID38_tree = default(object);
		object OPAR44_tree = default(object);
		object CPAR46_tree = default(object);
		RewriteRuleITokenStream stream_INT=new RewriteRuleITokenStream(adaptor,"token INT");
		RewriteRuleITokenStream stream_OPAR=new RewriteRuleITokenStream(adaptor,"token OPAR");
		RewriteRuleITokenStream stream_NIL=new RewriteRuleITokenStream(adaptor,"token NIL");
		RewriteRuleITokenStream stream_MINUS=new RewriteRuleITokenStream(adaptor,"token MINUS");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_BREAK=new RewriteRuleITokenStream(adaptor,"token BREAK");
		RewriteRuleITokenStream stream_CPAR=new RewriteRuleITokenStream(adaptor,"token CPAR");
		RewriteRuleITokenStream stream_STRING=new RewriteRuleITokenStream(adaptor,"token STRING");
		RewriteRuleSubtreeStream stream_let=new RewriteRuleSubtreeStream(adaptor,"rule let");
		RewriteRuleSubtreeStream stream_for=new RewriteRuleSubtreeStream(adaptor,"rule for");
		RewriteRuleSubtreeStream stream_expseq=new RewriteRuleSubtreeStream(adaptor,"rule expseq");
		RewriteRuleSubtreeStream stream_right=new RewriteRuleSubtreeStream(adaptor,"rule right");
		RewriteRuleSubtreeStream stream_auxEXP=new RewriteRuleSubtreeStream(adaptor,"rule auxEXP");
		RewriteRuleSubtreeStream stream_ifthen=new RewriteRuleSubtreeStream(adaptor,"rule ifthen");
		RewriteRuleSubtreeStream stream_while=new RewriteRuleSubtreeStream(adaptor,"rule while");
		try { DebugEnterRule(GrammarFileName, "auxEXP");
		DebugLocation(164, 42);
		try
		{
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:164:7: ( STRING -> STRING | MINUS auxEXP -> ^( NEG auxEXP ) | INT -> INT | NIL -> NIL | BREAK -> BREAK | ID ( right )? -> ^( VALUE ID ( right )? ) | ifthen -> ifthen | while -> while | for -> for | let -> let | OPAR ( expseq )? CPAR -> ^( EXPSEQ ( expseq )? ) )
			int alt8=11;
			try { DebugEnterDecision(8, false);
			switch (input.LA(1))
			{
			case STRING:
				{
				alt8 = 1;
				}
				break;
			case MINUS:
				{
				alt8 = 2;
				}
				break;
			case INT:
				{
				alt8 = 3;
				}
				break;
			case NIL:
				{
				alt8 = 4;
				}
				break;
			case BREAK:
				{
				alt8 = 5;
				}
				break;
			case ID:
				{
				alt8 = 6;
				}
				break;
			case IF:
				{
				alt8 = 7;
				}
				break;
			case WHILE:
				{
				alt8 = 8;
				}
				break;
			case FOR:
				{
				alt8 = 9;
				}
				break;
			case LET:
				{
				alt8 = 10;
				}
				break;
			case OPAR:
				{
				alt8 = 11;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 8, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(8); }
			switch (alt8)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:165:4: STRING
				{
				DebugLocation(165, 4);
				STRING32=(IToken)Match(input,STRING,Follow._STRING_in_auxEXP982); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_STRING.Add(STRING32);



				{
				// AST REWRITE
				// elements: STRING
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 165:11: -> STRING
				{
					DebugLocation(165, 14);
					adaptor.AddChild(root_0, stream_STRING.NextNode());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:166:5: MINUS auxEXP
				{
				DebugLocation(166, 5);
				MINUS33=(IToken)Match(input,MINUS,Follow._MINUS_in_auxEXP992); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_MINUS.Add(MINUS33);

				DebugLocation(166, 11);
				PushFollow(Follow._auxEXP_in_auxEXP994);
				auxEXP34=auxEXP();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_auxEXP.Add(auxEXP34.Tree);


				{
				// AST REWRITE
				// elements: auxEXP
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 166:18: -> ^( NEG auxEXP )
				{
					DebugLocation(166, 21);
					// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:166:21: ^( NEG auxEXP )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(166, 23);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(NEG, "NEG"), root_1);

					DebugLocation(166, 27);
					adaptor.AddChild(root_1, stream_auxEXP.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:167:5: INT
				{
				DebugLocation(167, 5);
				INT35=(IToken)Match(input,INT,Follow._INT_in_auxEXP1008); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_INT.Add(INT35);



				{
				// AST REWRITE
				// elements: INT
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 167:9: -> INT
				{
					DebugLocation(167, 12);
					adaptor.AddChild(root_0, stream_INT.NextNode());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:168:5: NIL
				{
				DebugLocation(168, 5);
				NIL36=(IToken)Match(input,NIL,Follow._NIL_in_auxEXP1018); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_NIL.Add(NIL36);



				{
				// AST REWRITE
				// elements: NIL
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 168:9: -> NIL
				{
					DebugLocation(168, 12);
					adaptor.AddChild(root_0, stream_NIL.NextNode());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:169:5: BREAK
				{
				DebugLocation(169, 5);
				BREAK37=(IToken)Match(input,BREAK,Follow._BREAK_in_auxEXP1028); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_BREAK.Add(BREAK37);



				{
				// AST REWRITE
				// elements: BREAK
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 169:11: -> BREAK
				{
					DebugLocation(169, 14);
					adaptor.AddChild(root_0, stream_BREAK.NextNode());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:170:5: ID ( right )?
				{
				DebugLocation(170, 5);
				ID38=(IToken)Match(input,ID,Follow._ID_in_auxEXP1038); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(ID38);

				DebugLocation(170, 8);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:170:8: ( right )?
				int alt6=2;
				try { DebugEnterSubRule(6);
				try { DebugEnterDecision(6, false);
				switch (input.LA(1))
				{
				case ASSIGN:
				case DOT:
				case OBRACK:
				case OKEYS:
				case OPAR:
					{
					alt6 = 1;
					}
					break;
				case MULT:
					{
					int LA6_2 = input.LA(2);

					if ((EvaluatePredicate(synpred18_tiger_fragment)))
					{
						alt6 = 1;
					}
					}
					break;
				case DIV:
					{
					int LA6_3 = input.LA(2);

					if ((EvaluatePredicate(synpred18_tiger_fragment)))
					{
						alt6 = 1;
					}
					}
					break;
				case PLUS:
					{
					int LA6_4 = input.LA(2);

					if ((EvaluatePredicate(synpred18_tiger_fragment)))
					{
						alt6 = 1;
					}
					}
					break;
				case MINUS:
					{
					int LA6_5 = input.LA(2);

					if ((EvaluatePredicate(synpred18_tiger_fragment)))
					{
						alt6 = 1;
					}
					}
					break;
				case EQ:
					{
					int LA6_6 = input.LA(2);

					if ((EvaluatePredicate(synpred18_tiger_fragment)))
					{
						alt6 = 1;
					}
					}
					break;
				case NOTEQ:
					{
					int LA6_7 = input.LA(2);

					if ((EvaluatePredicate(synpred18_tiger_fragment)))
					{
						alt6 = 1;
					}
					}
					break;
				case LTEQ:
					{
					int LA6_8 = input.LA(2);

					if ((EvaluatePredicate(synpred18_tiger_fragment)))
					{
						alt6 = 1;
					}
					}
					break;
				case GTEQ:
					{
					int LA6_9 = input.LA(2);

					if ((EvaluatePredicate(synpred18_tiger_fragment)))
					{
						alt6 = 1;
					}
					}
					break;
				case LT:
					{
					int LA6_10 = input.LA(2);

					if ((EvaluatePredicate(synpred18_tiger_fragment)))
					{
						alt6 = 1;
					}
					}
					break;
				case GT:
					{
					int LA6_11 = input.LA(2);

					if ((EvaluatePredicate(synpred18_tiger_fragment)))
					{
						alt6 = 1;
					}
					}
					break;
				case AND:
					{
					int LA6_12 = input.LA(2);

					if ((EvaluatePredicate(synpred18_tiger_fragment)))
					{
						alt6 = 1;
					}
					}
					break;
				case OR:
					{
					int LA6_13 = input.LA(2);

					if ((EvaluatePredicate(synpred18_tiger_fragment)))
					{
						alt6 = 1;
					}
					}
					break;
				case EOF:
					{
					int LA6_14 = input.LA(2);

					if ((EvaluatePredicate(synpred18_tiger_fragment)))
					{
						alt6 = 1;
					}
					}
					break;
				case CBRACK:
					{
					int LA6_15 = input.LA(2);

					if ((EvaluatePredicate(synpred18_tiger_fragment)))
					{
						alt6 = 1;
					}
					}
					break;
				case IN:
					{
					int LA6_16 = input.LA(2);

					if ((EvaluatePredicate(synpred18_tiger_fragment)))
					{
						alt6 = 1;
					}
					}
					break;
				case TYPETOK:
					{
					int LA6_17 = input.LA(2);

					if ((EvaluatePredicate(synpred18_tiger_fragment)))
					{
						alt6 = 1;
					}
					}
					break;
				case VAR:
					{
					int LA6_18 = input.LA(2);

					if ((EvaluatePredicate(synpred18_tiger_fragment)))
					{
						alt6 = 1;
					}
					}
					break;
				case FUNC:
					{
					int LA6_19 = input.LA(2);

					if ((EvaluatePredicate(synpred18_tiger_fragment)))
					{
						alt6 = 1;
					}
					}
					break;
				case TO:
					{
					int LA6_20 = input.LA(2);

					if ((EvaluatePredicate(synpred18_tiger_fragment)))
					{
						alt6 = 1;
					}
					}
					break;
				case DO:
					{
					int LA6_21 = input.LA(2);

					if ((EvaluatePredicate(synpred18_tiger_fragment)))
					{
						alt6 = 1;
					}
					}
					break;
				case THEN:
					{
					int LA6_22 = input.LA(2);

					if ((EvaluatePredicate(synpred18_tiger_fragment)))
					{
						alt6 = 1;
					}
					}
					break;
				case ELSE:
					{
					int LA6_23 = input.LA(2);

					if ((EvaluatePredicate(synpred18_tiger_fragment)))
					{
						alt6 = 1;
					}
					}
					break;
				case SMCOL:
					{
					int LA6_24 = input.LA(2);

					if ((EvaluatePredicate(synpred18_tiger_fragment)))
					{
						alt6 = 1;
					}
					}
					break;
				case CPAR:
					{
					int LA6_25 = input.LA(2);

					if ((EvaluatePredicate(synpred18_tiger_fragment)))
					{
						alt6 = 1;
					}
					}
					break;
				case END:
					{
					int LA6_26 = input.LA(2);

					if ((EvaluatePredicate(synpred18_tiger_fragment)))
					{
						alt6 = 1;
					}
					}
					break;
				case COMMA:
					{
					int LA6_27 = input.LA(2);

					if ((EvaluatePredicate(synpred18_tiger_fragment)))
					{
						alt6 = 1;
					}
					}
					break;
				case CKEYS:
					{
					int LA6_28 = input.LA(2);

					if ((EvaluatePredicate(synpred18_tiger_fragment)))
					{
						alt6 = 1;
					}
					}
					break;
				}

				} finally { DebugExitDecision(6); }
				switch (alt6)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:170:8: right
					{
					DebugLocation(170, 8);
					PushFollow(Follow._right_in_auxEXP1040);
					right39=right();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_right.Add(right39.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(6); }



				{
				// AST REWRITE
				// elements: right, ID
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 170:14: -> ^( VALUE ID ( right )? )
				{
					DebugLocation(170, 17);
					// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:170:17: ^( VALUE ID ( right )? )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(170, 19);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(VALUE, "VALUE"), root_1);

					DebugLocation(170, 25);
					adaptor.AddChild(root_1, stream_ID.NextNode());
					DebugLocation(170, 28);
					// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:170:28: ( right )?
					if (stream_right.HasNext)
					{
						DebugLocation(170, 28);
						adaptor.AddChild(root_1, stream_right.NextTree());

					}
					stream_right.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:171:5: ifthen
				{
				DebugLocation(171, 5);
				PushFollow(Follow._ifthen_in_auxEXP1057);
				ifthen40=ifthen();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_ifthen.Add(ifthen40.Tree);


				{
				// AST REWRITE
				// elements: ifthen
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 171:12: -> ifthen
				{
					DebugLocation(171, 15);
					adaptor.AddChild(root_0, stream_ifthen.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:172:6: while
				{
				DebugLocation(172, 6);
				PushFollow(Follow._while_in_auxEXP1068);
				while41=@while();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_while.Add(while41.Tree);


				{
				// AST REWRITE
				// elements: while
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 172:12: -> while
				{
					DebugLocation(172, 15);
					adaptor.AddChild(root_0, stream_while.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:173:5: for
				{
				DebugLocation(173, 5);
				PushFollow(Follow._for_in_auxEXP1078);
				for42=@for();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_for.Add(for42.Tree);


				{
				// AST REWRITE
				// elements: for
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 173:9: -> for
				{
					DebugLocation(173, 12);
					adaptor.AddChild(root_0, stream_for.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 10:
				DebugEnterAlt(10);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:174:5: let
				{
				DebugLocation(174, 5);
				PushFollow(Follow._let_in_auxEXP1088);
				let43=let();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_let.Add(let43.Tree);


				{
				// AST REWRITE
				// elements: let
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 174:9: -> let
				{
					DebugLocation(174, 12);
					adaptor.AddChild(root_0, stream_let.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 11:
				DebugEnterAlt(11);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:175:5: OPAR ( expseq )? CPAR
				{
				DebugLocation(175, 5);
				OPAR44=(IToken)Match(input,OPAR,Follow._OPAR_in_auxEXP1098); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_OPAR.Add(OPAR44);

				DebugLocation(175, 10);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:175:10: ( expseq )?
				int alt7=2;
				try { DebugEnterSubRule(7);
				try { DebugEnterDecision(7, false);
				int LA7_0 = input.LA(1);

				if ((LA7_0==BREAK||LA7_0==FOR||LA7_0==ID||LA7_0==IF||(LA7_0>=INT && LA7_0<=LET)||LA7_0==MINUS||LA7_0==NIL||LA7_0==OPAR||LA7_0==STRING||LA7_0==WHILE))
				{
					alt7 = 1;
				}
				} finally { DebugExitDecision(7); }
				switch (alt7)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:175:10: expseq
					{
					DebugLocation(175, 10);
					PushFollow(Follow._expseq_in_auxEXP1100);
					expseq45=expseq();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_expseq.Add(expseq45.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(7); }

				DebugLocation(175, 18);
				CPAR46=(IToken)Match(input,CPAR,Follow._CPAR_in_auxEXP1103); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_CPAR.Add(CPAR46);



				{
				// AST REWRITE
				// elements: expseq
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 175:23: -> ^( EXPSEQ ( expseq )? )
				{
					DebugLocation(175, 26);
					// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:175:26: ^( EXPSEQ ( expseq )? )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(175, 28);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(EXPSEQ, "EXPSEQ"), root_1);

					DebugLocation(175, 35);
					// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:175:35: ( expseq )?
					if (stream_expseq.HasNext)
					{
						DebugLocation(175, 35);
						adaptor.AddChild(root_1, stream_expseq.NextTree());

					}
					stream_expseq.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("auxEXP", 7);
			LeaveRule("auxEXP", 7);
			LeaveRule_auxEXP();
		}
		DebugLocation(175, 42);
		} finally { DebugExitRule(GrammarFileName, "auxEXP"); }
		return retval;

	}
	// $ANTLR end "auxEXP"

	partial void EnterRule_right();
	partial void LeaveRule_right();

	// $ANTLR start "right"
	// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:177:1: right : ( record -> record | array -> array | call -> call | ( lvalue )? ( assign )? -> ^( ACCESS ( lvalue )? ( assign )? ) );
	[GrammarRule("right")]
	private AstParserRuleReturnScope<object, IToken> right()
	{
		EnterRule_right();
		EnterRule("right", 8);
		TraceIn("right", 8);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> record47 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> array48 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> call49 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> lvalue50 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> assign51 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_call=new RewriteRuleSubtreeStream(adaptor,"rule call");
		RewriteRuleSubtreeStream stream_record=new RewriteRuleSubtreeStream(adaptor,"rule record");
		RewriteRuleSubtreeStream stream_assign=new RewriteRuleSubtreeStream(adaptor,"rule assign");
		RewriteRuleSubtreeStream stream_lvalue=new RewriteRuleSubtreeStream(adaptor,"rule lvalue");
		RewriteRuleSubtreeStream stream_array=new RewriteRuleSubtreeStream(adaptor,"rule array");
		try { DebugEnterRule(GrammarFileName, "right");
		DebugLocation(177, 50);
		try
		{
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:177:6: ( record -> record | array -> array | call -> call | ( lvalue )? ( assign )? -> ^( ACCESS ( lvalue )? ( assign )? ) )
			int alt11=4;
			try { DebugEnterDecision(11, false);
			switch (input.LA(1))
			{
			case OKEYS:
				{
				alt11 = 1;
				}
				break;
			case OBRACK:
				{
				int LA11_2 = input.LA(2);

				if ((EvaluatePredicate(synpred26_tiger_fragment)))
				{
					alt11 = 2;
				}
				else if ((true))
				{
					alt11 = 4;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 11, 2, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case OPAR:
				{
				alt11 = 3;
				}
				break;
			case EOF:
			case AND:
			case ASSIGN:
			case CBRACK:
			case CKEYS:
			case COMMA:
			case CPAR:
			case DIV:
			case DO:
			case DOT:
			case ELSE:
			case END:
			case EQ:
			case FUNC:
			case GT:
			case GTEQ:
			case IN:
			case LT:
			case LTEQ:
			case MINUS:
			case MULT:
			case NOTEQ:
			case OR:
			case PLUS:
			case SMCOL:
			case THEN:
			case TO:
			case TYPETOK:
			case VAR:
				{
				alt11 = 4;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 11, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(11); }
			switch (alt11)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:178:4: record
				{
				DebugLocation(178, 4);
				PushFollow(Follow._record_in_right1122);
				record47=record();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_record.Add(record47.Tree);


				{
				// AST REWRITE
				// elements: record
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 178:11: -> record
				{
					DebugLocation(178, 14);
					adaptor.AddChild(root_0, stream_record.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:179:7: array
				{
				DebugLocation(179, 7);
				PushFollow(Follow._array_in_right1135);
				array48=array();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_array.Add(array48.Tree);


				{
				// AST REWRITE
				// elements: array
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 179:13: -> array
				{
					DebugLocation(179, 16);
					adaptor.AddChild(root_0, stream_array.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:180:5: call
				{
				DebugLocation(180, 5);
				PushFollow(Follow._call_in_right1148);
				call49=call();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_call.Add(call49.Tree);


				{
				// AST REWRITE
				// elements: call
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 180:10: -> call
				{
					DebugLocation(180, 13);
					adaptor.AddChild(root_0, stream_call.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:181:7: ( lvalue )? ( assign )?
				{
				DebugLocation(181, 7);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:181:7: ( lvalue )?
				int alt9=2;
				try { DebugEnterSubRule(9);
				try { DebugEnterDecision(9, false);
				int LA9_0 = input.LA(1);

				if ((LA9_0==DOT||LA9_0==OBRACK))
				{
					alt9 = 1;
				}
				} finally { DebugExitDecision(9); }
				switch (alt9)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:181:7: lvalue
					{
					DebugLocation(181, 7);
					PushFollow(Follow._lvalue_in_right1160);
					lvalue50=lvalue();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_lvalue.Add(lvalue50.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(9); }

				DebugLocation(181, 15);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:181:15: ( assign )?
				int alt10=2;
				try { DebugEnterSubRule(10);
				try { DebugEnterDecision(10, false);
				int LA10_0 = input.LA(1);

				if ((LA10_0==ASSIGN))
				{
					alt10 = 1;
				}
				} finally { DebugExitDecision(10); }
				switch (alt10)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:181:15: assign
					{
					DebugLocation(181, 15);
					PushFollow(Follow._assign_in_right1163);
					assign51=assign();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_assign.Add(assign51.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(10); }



				{
				// AST REWRITE
				// elements: lvalue, assign
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 181:23: -> ^( ACCESS ( lvalue )? ( assign )? )
				{
					DebugLocation(181, 26);
					// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:181:26: ^( ACCESS ( lvalue )? ( assign )? )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(181, 28);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ACCESS, "ACCESS"), root_1);

					DebugLocation(181, 35);
					// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:181:35: ( lvalue )?
					if (stream_lvalue.HasNext)
					{
						DebugLocation(181, 35);
						adaptor.AddChild(root_1, stream_lvalue.NextTree());

					}
					stream_lvalue.Reset();
					DebugLocation(181, 43);
					// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:181:43: ( assign )?
					if (stream_assign.HasNext)
					{
						DebugLocation(181, 43);
						adaptor.AddChild(root_1, stream_assign.NextTree());

					}
					stream_assign.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("right", 8);
			LeaveRule("right", 8);
			LeaveRule_right();
		}
		DebugLocation(181, 50);
		} finally { DebugExitRule(GrammarFileName, "right"); }
		return retval;

	}
	// $ANTLR end "right"

	partial void EnterRule_array();
	partial void LeaveRule_array();

	// $ANTLR start "array"
	// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:183:1: array : OBRACK exp CBRACK OF exp -> ^( ARRAYDEC exp exp ) ;
	[GrammarRule("array")]
	private AstParserRuleReturnScope<object, IToken> array()
	{
		EnterRule_array();
		EnterRule("array", 9);
		TraceIn("array", 9);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken OBRACK52 = default(IToken);
		IToken CBRACK54 = default(IToken);
		IToken OF55 = default(IToken);
		AstParserRuleReturnScope<object, IToken> exp53 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> exp56 = default(AstParserRuleReturnScope<object, IToken>);

		object OBRACK52_tree = default(object);
		object CBRACK54_tree = default(object);
		object OF55_tree = default(object);
		RewriteRuleITokenStream stream_OF=new RewriteRuleITokenStream(adaptor,"token OF");
		RewriteRuleITokenStream stream_OBRACK=new RewriteRuleITokenStream(adaptor,"token OBRACK");
		RewriteRuleITokenStream stream_CBRACK=new RewriteRuleITokenStream(adaptor,"token CBRACK");
		RewriteRuleSubtreeStream stream_exp=new RewriteRuleSubtreeStream(adaptor,"rule exp");
		try { DebugEnterRule(GrammarFileName, "array");
		DebugLocation(183, 55);
		try
		{
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:183:6: ( OBRACK exp CBRACK OF exp -> ^( ARRAYDEC exp exp ) )
			DebugEnterAlt(1);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:183:9: OBRACK exp CBRACK OF exp
			{
			DebugLocation(183, 9);
			OBRACK52=(IToken)Match(input,OBRACK,Follow._OBRACK_in_array1185); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_OBRACK.Add(OBRACK52);

			DebugLocation(183, 16);
			PushFollow(Follow._exp_in_array1187);
			exp53=exp();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_exp.Add(exp53.Tree);
			DebugLocation(183, 20);
			CBRACK54=(IToken)Match(input,CBRACK,Follow._CBRACK_in_array1189); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_CBRACK.Add(CBRACK54);

			DebugLocation(183, 27);
			OF55=(IToken)Match(input,OF,Follow._OF_in_array1191); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_OF.Add(OF55);

			DebugLocation(183, 30);
			PushFollow(Follow._exp_in_array1193);
			exp56=exp();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_exp.Add(exp56.Tree);


			{
			// AST REWRITE
			// elements: exp, exp
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 183:34: -> ^( ARRAYDEC exp exp )
			{
				DebugLocation(183, 37);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:183:37: ^( ARRAYDEC exp exp )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(183, 39);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ARRAYDEC, "ARRAYDEC"), root_1);

				DebugLocation(183, 48);
				adaptor.AddChild(root_1, stream_exp.NextTree());
				DebugLocation(183, 52);
				adaptor.AddChild(root_1, stream_exp.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("array", 9);
			LeaveRule("array", 9);
			LeaveRule_array();
		}
		DebugLocation(183, 55);
		} finally { DebugExitRule(GrammarFileName, "array"); }
		return retval;

	}
	// $ANTLR end "array"

	partial void EnterRule_record();
	partial void LeaveRule_record();

	// $ANTLR start "record"
	// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:185:1: record : OKEYS ( fieldlist )? CKEYS -> ^( RECORDDEC ( fieldlist )? ) ;
	[GrammarRule("record")]
	private AstParserRuleReturnScope<object, IToken> record()
	{
		EnterRule_record();
		EnterRule("record", 10);
		TraceIn("record", 10);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken OKEYS57 = default(IToken);
		IToken CKEYS59 = default(IToken);
		AstParserRuleReturnScope<object, IToken> fieldlist58 = default(AstParserRuleReturnScope<object, IToken>);

		object OKEYS57_tree = default(object);
		object CKEYS59_tree = default(object);
		RewriteRuleITokenStream stream_OKEYS=new RewriteRuleITokenStream(adaptor,"token OKEYS");
		RewriteRuleITokenStream stream_CKEYS=new RewriteRuleITokenStream(adaptor,"token CKEYS");
		RewriteRuleSubtreeStream stream_fieldlist=new RewriteRuleSubtreeStream(adaptor,"rule fieldlist");
		try { DebugEnterRule(GrammarFileName, "record");
		DebugLocation(185, 58);
		try
		{
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:185:7: ( OKEYS ( fieldlist )? CKEYS -> ^( RECORDDEC ( fieldlist )? ) )
			DebugEnterAlt(1);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:185:10: OKEYS ( fieldlist )? CKEYS
			{
			DebugLocation(185, 10);
			OKEYS57=(IToken)Match(input,OKEYS,Follow._OKEYS_in_record1211); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_OKEYS.Add(OKEYS57);

			DebugLocation(185, 16);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:185:16: ( fieldlist )?
			int alt12=2;
			try { DebugEnterSubRule(12);
			try { DebugEnterDecision(12, false);
			int LA12_0 = input.LA(1);

			if ((LA12_0==ID))
			{
				alt12 = 1;
			}
			} finally { DebugExitDecision(12); }
			switch (alt12)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:185:16: fieldlist
				{
				DebugLocation(185, 16);
				PushFollow(Follow._fieldlist_in_record1213);
				fieldlist58=fieldlist();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_fieldlist.Add(fieldlist58.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(12); }

			DebugLocation(185, 27);
			CKEYS59=(IToken)Match(input,CKEYS,Follow._CKEYS_in_record1216); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_CKEYS.Add(CKEYS59);



			{
			// AST REWRITE
			// elements: fieldlist
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 185:33: -> ^( RECORDDEC ( fieldlist )? )
			{
				DebugLocation(185, 36);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:185:36: ^( RECORDDEC ( fieldlist )? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(185, 38);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(RECORDDEC, "RECORDDEC"), root_1);

				DebugLocation(185, 48);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:185:48: ( fieldlist )?
				if (stream_fieldlist.HasNext)
				{
					DebugLocation(185, 48);
					adaptor.AddChild(root_1, stream_fieldlist.NextTree());

				}
				stream_fieldlist.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("record", 10);
			LeaveRule("record", 10);
			LeaveRule_record();
		}
		DebugLocation(185, 58);
		} finally { DebugExitRule(GrammarFileName, "record"); }
		return retval;

	}
	// $ANTLR end "record"

	partial void EnterRule_let();
	partial void LeaveRule_let();

	// $ANTLR start "let"
	// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:187:1: let : LET declist IN ( expseq )? END -> ^( DECLIST declist ( ^( EXPSEQ expseq ) )? ) ;
	[GrammarRule("let")]
	private AstParserRuleReturnScope<object, IToken> let()
	{
		EnterRule_let();
		EnterRule("let", 11);
		TraceIn("let", 11);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken LET60 = default(IToken);
		IToken IN62 = default(IToken);
		IToken END64 = default(IToken);
		AstParserRuleReturnScope<object, IToken> declist61 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expseq63 = default(AstParserRuleReturnScope<object, IToken>);

		object LET60_tree = default(object);
		object IN62_tree = default(object);
		object END64_tree = default(object);
		RewriteRuleITokenStream stream_IN=new RewriteRuleITokenStream(adaptor,"token IN");
		RewriteRuleITokenStream stream_END=new RewriteRuleITokenStream(adaptor,"token END");
		RewriteRuleITokenStream stream_LET=new RewriteRuleITokenStream(adaptor,"token LET");
		RewriteRuleSubtreeStream stream_declist=new RewriteRuleSubtreeStream(adaptor,"rule declist");
		RewriteRuleSubtreeStream stream_expseq=new RewriteRuleSubtreeStream(adaptor,"rule expseq");
		try { DebugEnterRule(GrammarFileName, "let");
		DebugLocation(187, 72);
		try
		{
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:187:4: ( LET declist IN ( expseq )? END -> ^( DECLIST declist ( ^( EXPSEQ expseq ) )? ) )
			DebugEnterAlt(1);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:187:7: LET declist IN ( expseq )? END
			{
			DebugLocation(187, 7);
			LET60=(IToken)Match(input,LET,Follow._LET_in_let1233); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LET.Add(LET60);

			DebugLocation(187, 11);
			PushFollow(Follow._declist_in_let1235);
			declist61=declist();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_declist.Add(declist61.Tree);
			DebugLocation(187, 19);
			IN62=(IToken)Match(input,IN,Follow._IN_in_let1237); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_IN.Add(IN62);

			DebugLocation(187, 22);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:187:22: ( expseq )?
			int alt13=2;
			try { DebugEnterSubRule(13);
			try { DebugEnterDecision(13, false);
			int LA13_0 = input.LA(1);

			if ((LA13_0==BREAK||LA13_0==FOR||LA13_0==ID||LA13_0==IF||(LA13_0>=INT && LA13_0<=LET)||LA13_0==MINUS||LA13_0==NIL||LA13_0==OPAR||LA13_0==STRING||LA13_0==WHILE))
			{
				alt13 = 1;
			}
			} finally { DebugExitDecision(13); }
			switch (alt13)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:187:22: expseq
				{
				DebugLocation(187, 22);
				PushFollow(Follow._expseq_in_let1239);
				expseq63=expseq();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expseq.Add(expseq63.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(13); }

			DebugLocation(187, 30);
			END64=(IToken)Match(input,END,Follow._END_in_let1242); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_END.Add(END64);



			{
			// AST REWRITE
			// elements: expseq, declist
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 187:34: -> ^( DECLIST declist ( ^( EXPSEQ expseq ) )? )
			{
				DebugLocation(187, 37);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:187:37: ^( DECLIST declist ( ^( EXPSEQ expseq ) )? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(187, 39);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(DECLIST, "DECLIST"), root_1);

				DebugLocation(187, 47);
				adaptor.AddChild(root_1, stream_declist.NextTree());
				DebugLocation(187, 55);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:187:55: ( ^( EXPSEQ expseq ) )?
				if (stream_expseq.HasNext)
				{
					DebugLocation(187, 55);
					// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:187:55: ^( EXPSEQ expseq )
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(187, 57);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(EXPSEQ, "EXPSEQ"), root_2);

					DebugLocation(187, 64);
					adaptor.AddChild(root_2, stream_expseq.NextTree());

					adaptor.AddChild(root_1, root_2);
					}

				}
				stream_expseq.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("let", 11);
			LeaveRule("let", 11);
			LeaveRule_let();
		}
		DebugLocation(187, 72);
		} finally { DebugExitRule(GrammarFileName, "let"); }
		return retval;

	}
	// $ANTLR end "let"

	partial void EnterRule_declist();
	partial void LeaveRule_declist();

	// $ANTLR start "declist"
	// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:189:1: declist : ( declaration )+ -> ( declaration )+ ;
	[GrammarRule("declist")]
	private AstParserRuleReturnScope<object, IToken> declist()
	{
		EnterRule_declist();
		EnterRule("declist", 12);
		TraceIn("declist", 12);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> declaration65 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_declaration=new RewriteRuleSubtreeStream(adaptor,"rule declaration");
		try { DebugEnterRule(GrammarFileName, "declist");
		DebugLocation(189, 39);
		try
		{
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:189:9: ( ( declaration )+ -> ( declaration )+ )
			DebugEnterAlt(1);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:189:12: ( declaration )+
			{
			DebugLocation(189, 12);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:189:12: ( declaration )+
			int cnt14=0;
			try { DebugEnterSubRule(14);
			while (true)
			{
				int alt14=2;
				try { DebugEnterDecision(14, false);
				int LA14_0 = input.LA(1);

				if ((LA14_0==FUNC||LA14_0==TYPETOK||LA14_0==VAR))
				{
					alt14 = 1;
				}


				} finally { DebugExitDecision(14); }
				switch (alt14)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:189:12: declaration
					{
					DebugLocation(189, 12);
					PushFollow(Follow._declaration_in_declist1266);
					declaration65=declaration();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_declaration.Add(declaration65.Tree);

					}
					break;

				default:
					if (cnt14 >= 1)
						goto loop14;

					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee14 = new EarlyExitException( 14, input );
					DebugRecognitionException(eee14);
					throw eee14;
				}
				cnt14++;
			}
			loop14:
				;

			} finally { DebugExitSubRule(14); }



			{
			// AST REWRITE
			// elements: declaration
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 189:25: -> ( declaration )+
			{
				DebugLocation(189, 28);
				if (!(stream_declaration.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_declaration.HasNext )
				{
					DebugLocation(189, 28);
					adaptor.AddChild(root_0, stream_declaration.NextTree());

				}
				stream_declaration.Reset();

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("declist", 12);
			LeaveRule("declist", 12);
			LeaveRule_declist();
		}
		DebugLocation(189, 39);
		} finally { DebugExitRule(GrammarFileName, "declist"); }
		return retval;

	}
	// $ANTLR end "declist"

	partial void EnterRule_declaration();
	partial void LeaveRule_declaration();

	// $ANTLR start "declaration"
	// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:191:1: declaration : ( type_decl_block | var_decl_block | func_decl_block );
	[GrammarRule("declaration")]
	private AstParserRuleReturnScope<object, IToken> declaration()
	{
		EnterRule_declaration();
		EnterRule("declaration", 13);
		TraceIn("declaration", 13);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> type_decl_block66 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> var_decl_block67 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> func_decl_block68 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "declaration");
		DebugLocation(191, 63);
		try
		{
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:191:12: ( type_decl_block | var_decl_block | func_decl_block )
			int alt15=3;
			try { DebugEnterDecision(15, false);
			switch (input.LA(1))
			{
			case TYPETOK:
				{
				alt15 = 1;
				}
				break;
			case VAR:
				{
				alt15 = 2;
				}
				break;
			case FUNC:
				{
				alt15 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 15, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(15); }
			switch (alt15)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:191:14: type_decl_block
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(191, 14);
				PushFollow(Follow._type_decl_block_in_declaration1279);
				type_decl_block66=type_decl_block();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, type_decl_block66.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:191:32: var_decl_block
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(191, 32);
				PushFollow(Follow._var_decl_block_in_declaration1283);
				var_decl_block67=var_decl_block();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, var_decl_block67.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:191:49: func_decl_block
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(191, 49);
				PushFollow(Follow._func_decl_block_in_declaration1287);
				func_decl_block68=func_decl_block();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, func_decl_block68.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("declaration", 13);
			LeaveRule("declaration", 13);
			LeaveRule_declaration();
		}
		DebugLocation(191, 63);
		} finally { DebugExitRule(GrammarFileName, "declaration"); }
		return retval;

	}
	// $ANTLR end "declaration"

	partial void EnterRule_type_decl_block();
	partial void LeaveRule_type_decl_block();

	// $ANTLR start "type_decl_block"
	// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:193:1: type_decl_block : ( typedec )+ -> ^( TYPEBLOCK ( typedec )+ ) ;
	[GrammarRule("type_decl_block")]
	private AstParserRuleReturnScope<object, IToken> type_decl_block()
	{
		EnterRule_type_decl_block();
		EnterRule("type_decl_block", 14);
		TraceIn("type_decl_block", 14);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> typedec69 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_typedec=new RewriteRuleSubtreeStream(adaptor,"rule typedec");
		try { DebugEnterRule(GrammarFileName, "type_decl_block");
		DebugLocation(193, 50);
		try
		{
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:193:16: ( ( typedec )+ -> ^( TYPEBLOCK ( typedec )+ ) )
			DebugEnterAlt(1);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:193:18: ( typedec )+
			{
			DebugLocation(193, 18);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:193:18: ( typedec )+
			int cnt16=0;
			try { DebugEnterSubRule(16);
			while (true)
			{
				int alt16=2;
				try { DebugEnterDecision(16, false);
				int LA16_0 = input.LA(1);

				if ((LA16_0==TYPETOK))
				{
					int LA16_2 = input.LA(2);

					if ((EvaluatePredicate(synpred35_tiger_fragment)))
					{
						alt16 = 1;
					}


				}


				} finally { DebugExitDecision(16); }
				switch (alt16)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:193:18: typedec
					{
					DebugLocation(193, 18);
					PushFollow(Follow._typedec_in_type_decl_block1295);
					typedec69=typedec();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_typedec.Add(typedec69.Tree);

					}
					break;

				default:
					if (cnt16 >= 1)
						goto loop16;

					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee16 = new EarlyExitException( 16, input );
					DebugRecognitionException(eee16);
					throw eee16;
				}
				cnt16++;
			}
			loop16:
				;

			} finally { DebugExitSubRule(16); }



			{
			// AST REWRITE
			// elements: typedec
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 193:27: -> ^( TYPEBLOCK ( typedec )+ )
			{
				DebugLocation(193, 30);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:193:30: ^( TYPEBLOCK ( typedec )+ )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(193, 32);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(TYPEBLOCK, "TYPEBLOCK"), root_1);

				DebugLocation(193, 42);
				if (!(stream_typedec.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_typedec.HasNext )
				{
					DebugLocation(193, 42);
					adaptor.AddChild(root_1, stream_typedec.NextTree());

				}
				stream_typedec.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("type_decl_block", 14);
			LeaveRule("type_decl_block", 14);
			LeaveRule_type_decl_block();
		}
		DebugLocation(193, 50);
		} finally { DebugExitRule(GrammarFileName, "type_decl_block"); }
		return retval;

	}
	// $ANTLR end "type_decl_block"

	partial void EnterRule_var_decl_block();
	partial void LeaveRule_var_decl_block();

	// $ANTLR start "var_decl_block"
	// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:195:1: var_decl_block : ( vardec )+ -> ^( VARBLOCK ( vardec )+ ) ;
	[GrammarRule("var_decl_block")]
	private AstParserRuleReturnScope<object, IToken> var_decl_block()
	{
		EnterRule_var_decl_block();
		EnterRule("var_decl_block", 15);
		TraceIn("var_decl_block", 15);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> vardec70 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_vardec=new RewriteRuleSubtreeStream(adaptor,"rule vardec");
		try { DebugEnterRule(GrammarFileName, "var_decl_block");
		DebugLocation(195, 47);
		try
		{
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:195:15: ( ( vardec )+ -> ^( VARBLOCK ( vardec )+ ) )
			DebugEnterAlt(1);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:195:17: ( vardec )+
			{
			DebugLocation(195, 17);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:195:17: ( vardec )+
			int cnt17=0;
			try { DebugEnterSubRule(17);
			while (true)
			{
				int alt17=2;
				try { DebugEnterDecision(17, false);
				int LA17_0 = input.LA(1);

				if ((LA17_0==VAR))
				{
					int LA17_2 = input.LA(2);

					if ((EvaluatePredicate(synpred36_tiger_fragment)))
					{
						alt17 = 1;
					}


				}


				} finally { DebugExitDecision(17); }
				switch (alt17)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:195:17: vardec
					{
					DebugLocation(195, 17);
					PushFollow(Follow._vardec_in_var_decl_block1313);
					vardec70=vardec();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_vardec.Add(vardec70.Tree);

					}
					break;

				default:
					if (cnt17 >= 1)
						goto loop17;

					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee17 = new EarlyExitException( 17, input );
					DebugRecognitionException(eee17);
					throw eee17;
				}
				cnt17++;
			}
			loop17:
				;

			} finally { DebugExitSubRule(17); }



			{
			// AST REWRITE
			// elements: vardec
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 195:26: -> ^( VARBLOCK ( vardec )+ )
			{
				DebugLocation(195, 29);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:195:29: ^( VARBLOCK ( vardec )+ )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(195, 31);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(VARBLOCK, "VARBLOCK"), root_1);

				DebugLocation(195, 40);
				if (!(stream_vardec.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_vardec.HasNext )
				{
					DebugLocation(195, 40);
					adaptor.AddChild(root_1, stream_vardec.NextTree());

				}
				stream_vardec.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("var_decl_block", 15);
			LeaveRule("var_decl_block", 15);
			LeaveRule_var_decl_block();
		}
		DebugLocation(195, 47);
		} finally { DebugExitRule(GrammarFileName, "var_decl_block"); }
		return retval;

	}
	// $ANTLR end "var_decl_block"

	partial void EnterRule_func_decl_block();
	partial void LeaveRule_func_decl_block();

	// $ANTLR start "func_decl_block"
	// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:197:1: func_decl_block : ( funcdec )+ -> ^( FUNCBLOCK ( funcdec )+ ) ;
	[GrammarRule("func_decl_block")]
	private AstParserRuleReturnScope<object, IToken> func_decl_block()
	{
		EnterRule_func_decl_block();
		EnterRule("func_decl_block", 16);
		TraceIn("func_decl_block", 16);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> funcdec71 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_funcdec=new RewriteRuleSubtreeStream(adaptor,"rule funcdec");
		try { DebugEnterRule(GrammarFileName, "func_decl_block");
		DebugLocation(197, 50);
		try
		{
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:197:16: ( ( funcdec )+ -> ^( FUNCBLOCK ( funcdec )+ ) )
			DebugEnterAlt(1);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:197:18: ( funcdec )+
			{
			DebugLocation(197, 18);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:197:18: ( funcdec )+
			int cnt18=0;
			try { DebugEnterSubRule(18);
			while (true)
			{
				int alt18=2;
				try { DebugEnterDecision(18, false);
				int LA18_0 = input.LA(1);

				if ((LA18_0==FUNC))
				{
					int LA18_2 = input.LA(2);

					if ((EvaluatePredicate(synpred37_tiger_fragment)))
					{
						alt18 = 1;
					}


				}


				} finally { DebugExitDecision(18); }
				switch (alt18)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:197:18: funcdec
					{
					DebugLocation(197, 18);
					PushFollow(Follow._funcdec_in_func_decl_block1332);
					funcdec71=funcdec();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_funcdec.Add(funcdec71.Tree);

					}
					break;

				default:
					if (cnt18 >= 1)
						goto loop18;

					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee18 = new EarlyExitException( 18, input );
					DebugRecognitionException(eee18);
					throw eee18;
				}
				cnt18++;
			}
			loop18:
				;

			} finally { DebugExitSubRule(18); }



			{
			// AST REWRITE
			// elements: funcdec
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 197:27: -> ^( FUNCBLOCK ( funcdec )+ )
			{
				DebugLocation(197, 30);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:197:30: ^( FUNCBLOCK ( funcdec )+ )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(197, 32);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(FUNCBLOCK, "FUNCBLOCK"), root_1);

				DebugLocation(197, 42);
				if (!(stream_funcdec.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_funcdec.HasNext )
				{
					DebugLocation(197, 42);
					adaptor.AddChild(root_1, stream_funcdec.NextTree());

				}
				stream_funcdec.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("func_decl_block", 16);
			LeaveRule("func_decl_block", 16);
			LeaveRule_func_decl_block();
		}
		DebugLocation(197, 50);
		} finally { DebugExitRule(GrammarFileName, "func_decl_block"); }
		return retval;

	}
	// $ANTLR end "func_decl_block"

	partial void EnterRule_typedec();
	partial void LeaveRule_typedec();

	// $ANTLR start "typedec"
	// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:200:1: typedec : TYPETOK ID EQ type -> ^( TYPEDEC ID type ) ;
	[GrammarRule("typedec")]
	private AstParserRuleReturnScope<object, IToken> typedec()
	{
		EnterRule_typedec();
		EnterRule("typedec", 17);
		TraceIn("typedec", 17);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken TYPETOK72 = default(IToken);
		IToken ID73 = default(IToken);
		IToken EQ74 = default(IToken);
		AstParserRuleReturnScope<object, IToken> type75 = default(AstParserRuleReturnScope<object, IToken>);

		object TYPETOK72_tree = default(object);
		object ID73_tree = default(object);
		object EQ74_tree = default(object);
		RewriteRuleITokenStream stream_EQ=new RewriteRuleITokenStream(adaptor,"token EQ");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_TYPETOK=new RewriteRuleITokenStream(adaptor,"token TYPETOK");
		RewriteRuleSubtreeStream stream_type=new RewriteRuleSubtreeStream(adaptor,"rule type");
		try { DebugEnterRule(GrammarFileName, "typedec");
		DebugLocation(200, 50);
		try
		{
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:200:9: ( TYPETOK ID EQ type -> ^( TYPEDEC ID type ) )
			DebugEnterAlt(1);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:200:11: TYPETOK ID EQ type
			{
			DebugLocation(200, 11);
			TYPETOK72=(IToken)Match(input,TYPETOK,Follow._TYPETOK_in_typedec1352); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_TYPETOK.Add(TYPETOK72);

			DebugLocation(200, 19);
			ID73=(IToken)Match(input,ID,Follow._ID_in_typedec1354); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(ID73);

			DebugLocation(200, 22);
			EQ74=(IToken)Match(input,EQ,Follow._EQ_in_typedec1356); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_EQ.Add(EQ74);

			DebugLocation(200, 25);
			PushFollow(Follow._type_in_typedec1358);
			type75=type();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_type.Add(type75.Tree);


			{
			// AST REWRITE
			// elements: type, ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 200:30: -> ^( TYPEDEC ID type )
			{
				DebugLocation(200, 33);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:200:33: ^( TYPEDEC ID type )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(200, 35);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(TYPEDEC, "TYPEDEC"), root_1);

				DebugLocation(200, 43);
				adaptor.AddChild(root_1, stream_ID.NextNode());
				DebugLocation(200, 46);
				adaptor.AddChild(root_1, stream_type.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("typedec", 17);
			LeaveRule("typedec", 17);
			LeaveRule_typedec();
		}
		DebugLocation(200, 50);
		} finally { DebugExitRule(GrammarFileName, "typedec"); }
		return retval;

	}
	// $ANTLR end "typedec"

	partial void EnterRule_type();
	partial void LeaveRule_type();

	// $ANTLR start "type"
	// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:202:1: type : ( TYPE -> TYPE | ID -> ID | OKEYS ( typefields )? CKEYS -> ^( RECORDTYPE ( typefields )? ) | ARRAY OF ( TYPE -> ^( ARRAYTYPE TYPE ) | ID -> ^( ARRAYTYPE ID ) ) );
	[GrammarRule("type")]
	private AstParserRuleReturnScope<object, IToken> type()
	{
		EnterRule_type();
		EnterRule("type", 18);
		TraceIn("type", 18);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken TYPE76 = default(IToken);
		IToken ID77 = default(IToken);
		IToken OKEYS78 = default(IToken);
		IToken CKEYS80 = default(IToken);
		IToken ARRAY81 = default(IToken);
		IToken OF82 = default(IToken);
		IToken TYPE83 = default(IToken);
		IToken ID84 = default(IToken);
		AstParserRuleReturnScope<object, IToken> typefields79 = default(AstParserRuleReturnScope<object, IToken>);

		object TYPE76_tree = default(object);
		object ID77_tree = default(object);
		object OKEYS78_tree = default(object);
		object CKEYS80_tree = default(object);
		object ARRAY81_tree = default(object);
		object OF82_tree = default(object);
		object TYPE83_tree = default(object);
		object ID84_tree = default(object);
		RewriteRuleITokenStream stream_OKEYS=new RewriteRuleITokenStream(adaptor,"token OKEYS");
		RewriteRuleITokenStream stream_CKEYS=new RewriteRuleITokenStream(adaptor,"token CKEYS");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_OF=new RewriteRuleITokenStream(adaptor,"token OF");
		RewriteRuleITokenStream stream_ARRAY=new RewriteRuleITokenStream(adaptor,"token ARRAY");
		RewriteRuleITokenStream stream_TYPE=new RewriteRuleITokenStream(adaptor,"token TYPE");
		RewriteRuleSubtreeStream stream_typefields=new RewriteRuleSubtreeStream(adaptor,"rule typefields");
		try { DebugEnterRule(GrammarFileName, "type");
		DebugLocation(202, 64);
		try
		{
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:202:6: ( TYPE -> TYPE | ID -> ID | OKEYS ( typefields )? CKEYS -> ^( RECORDTYPE ( typefields )? ) | ARRAY OF ( TYPE -> ^( ARRAYTYPE TYPE ) | ID -> ^( ARRAYTYPE ID ) ) )
			int alt21=4;
			try { DebugEnterDecision(21, false);
			switch (input.LA(1))
			{
			case TYPE:
				{
				alt21 = 1;
				}
				break;
			case ID:
				{
				alt21 = 2;
				}
				break;
			case OKEYS:
				{
				alt21 = 3;
				}
				break;
			case ARRAY:
				{
				alt21 = 4;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 21, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(21); }
			switch (alt21)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:203:3: TYPE
				{
				DebugLocation(203, 3);
				TYPE76=(IToken)Match(input,TYPE,Follow._TYPE_in_type1379); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_TYPE.Add(TYPE76);



				{
				// AST REWRITE
				// elements: TYPE
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 203:8: -> TYPE
				{
					DebugLocation(203, 11);
					adaptor.AddChild(root_0, stream_TYPE.NextNode());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:204:5: ID
				{
				DebugLocation(204, 5);
				ID77=(IToken)Match(input,ID,Follow._ID_in_type1390); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(ID77);



				{
				// AST REWRITE
				// elements: ID
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 204:8: -> ID
				{
					DebugLocation(204, 11);
					adaptor.AddChild(root_0, stream_ID.NextNode());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:205:5: OKEYS ( typefields )? CKEYS
				{
				DebugLocation(205, 5);
				OKEYS78=(IToken)Match(input,OKEYS,Follow._OKEYS_in_type1400); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_OKEYS.Add(OKEYS78);

				DebugLocation(205, 11);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:205:11: ( typefields )?
				int alt19=2;
				try { DebugEnterSubRule(19);
				try { DebugEnterDecision(19, false);
				int LA19_0 = input.LA(1);

				if ((LA19_0==ID))
				{
					alt19 = 1;
				}
				} finally { DebugExitDecision(19); }
				switch (alt19)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:205:11: typefields
					{
					DebugLocation(205, 11);
					PushFollow(Follow._typefields_in_type1402);
					typefields79=typefields();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_typefields.Add(typefields79.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(19); }

				DebugLocation(205, 23);
				CKEYS80=(IToken)Match(input,CKEYS,Follow._CKEYS_in_type1405); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_CKEYS.Add(CKEYS80);



				{
				// AST REWRITE
				// elements: typefields
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 205:29: -> ^( RECORDTYPE ( typefields )? )
				{
					DebugLocation(205, 32);
					// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:205:32: ^( RECORDTYPE ( typefields )? )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(205, 34);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(RECORDTYPE, "RECORDTYPE"), root_1);

					DebugLocation(205, 45);
					// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:205:45: ( typefields )?
					if (stream_typefields.HasNext)
					{
						DebugLocation(205, 45);
						adaptor.AddChild(root_1, stream_typefields.NextTree());

					}
					stream_typefields.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:206:5: ARRAY OF ( TYPE -> ^( ARRAYTYPE TYPE ) | ID -> ^( ARRAYTYPE ID ) )
				{
				DebugLocation(206, 5);
				ARRAY81=(IToken)Match(input,ARRAY,Follow._ARRAY_in_type1420); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ARRAY.Add(ARRAY81);

				DebugLocation(206, 11);
				OF82=(IToken)Match(input,OF,Follow._OF_in_type1422); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_OF.Add(OF82);

				DebugLocation(206, 14);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:206:14: ( TYPE -> ^( ARRAYTYPE TYPE ) | ID -> ^( ARRAYTYPE ID ) )
				int alt20=2;
				try { DebugEnterSubRule(20);
				try { DebugEnterDecision(20, false);
				int LA20_0 = input.LA(1);

				if ((LA20_0==TYPE))
				{
					alt20 = 1;
				}
				else if ((LA20_0==ID))
				{
					alt20 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 20, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(20); }
				switch (alt20)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:206:15: TYPE
					{
					DebugLocation(206, 15);
					TYPE83=(IToken)Match(input,TYPE,Follow._TYPE_in_type1425); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_TYPE.Add(TYPE83);



					{
					// AST REWRITE
					// elements: TYPE
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (object)adaptor.Nil();
					// 206:20: -> ^( ARRAYTYPE TYPE )
					{
						DebugLocation(206, 23);
						// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:206:23: ^( ARRAYTYPE TYPE )
						{
						object root_1 = (object)adaptor.Nil();
						DebugLocation(206, 25);
						root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ARRAYTYPE, "ARRAYTYPE"), root_1);

						DebugLocation(206, 35);
						adaptor.AddChild(root_1, stream_TYPE.NextNode());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:206:43: ID
					{
					DebugLocation(206, 43);
					ID84=(IToken)Match(input,ID,Follow._ID_in_type1437); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_ID.Add(ID84);



					{
					// AST REWRITE
					// elements: ID
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (object)adaptor.Nil();
					// 206:46: -> ^( ARRAYTYPE ID )
					{
						DebugLocation(206, 49);
						// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:206:49: ^( ARRAYTYPE ID )
						{
						object root_1 = (object)adaptor.Nil();
						DebugLocation(206, 51);
						root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ARRAYTYPE, "ARRAYTYPE"), root_1);

						DebugLocation(206, 61);
						adaptor.AddChild(root_1, stream_ID.NextNode());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;

				}
				} finally { DebugExitSubRule(20); }


				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("type", 18);
			LeaveRule("type", 18);
			LeaveRule_type();
		}
		DebugLocation(206, 64);
		} finally { DebugExitRule(GrammarFileName, "type"); }
		return retval;

	}
	// $ANTLR end "type"

	partial void EnterRule_funcdec();
	partial void LeaveRule_funcdec();

	// $ANTLR start "funcdec"
	// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:208:1: funcdec : FUNC ID OPAR ( typefields )? CPAR procOrfunc -> ^( FUNCDEC ID ( typefields )? procOrfunc ) ;
	[GrammarRule("funcdec")]
	private AstParserRuleReturnScope<object, IToken> funcdec()
	{
		EnterRule_funcdec();
		EnterRule("funcdec", 19);
		TraceIn("funcdec", 19);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken FUNC85 = default(IToken);
		IToken ID86 = default(IToken);
		IToken OPAR87 = default(IToken);
		IToken CPAR89 = default(IToken);
		AstParserRuleReturnScope<object, IToken> typefields88 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> procOrfunc90 = default(AstParserRuleReturnScope<object, IToken>);

		object FUNC85_tree = default(object);
		object ID86_tree = default(object);
		object OPAR87_tree = default(object);
		object CPAR89_tree = default(object);
		RewriteRuleITokenStream stream_OPAR=new RewriteRuleITokenStream(adaptor,"token OPAR");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_FUNC=new RewriteRuleITokenStream(adaptor,"token FUNC");
		RewriteRuleITokenStream stream_CPAR=new RewriteRuleITokenStream(adaptor,"token CPAR");
		RewriteRuleSubtreeStream stream_procOrfunc=new RewriteRuleSubtreeStream(adaptor,"rule procOrfunc");
		RewriteRuleSubtreeStream stream_typefields=new RewriteRuleSubtreeStream(adaptor,"rule typefields");
		try { DebugEnterRule(GrammarFileName, "funcdec");
		DebugLocation(208, 41);
		try
		{
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:208:9: ( FUNC ID OPAR ( typefields )? CPAR procOrfunc -> ^( FUNCDEC ID ( typefields )? procOrfunc ) )
			DebugEnterAlt(1);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:208:11: FUNC ID OPAR ( typefields )? CPAR procOrfunc
			{
			DebugLocation(208, 11);
			FUNC85=(IToken)Match(input,FUNC,Follow._FUNC_in_funcdec1454); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_FUNC.Add(FUNC85);

			DebugLocation(208, 16);
			ID86=(IToken)Match(input,ID,Follow._ID_in_funcdec1456); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(ID86);

			DebugLocation(208, 19);
			OPAR87=(IToken)Match(input,OPAR,Follow._OPAR_in_funcdec1458); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_OPAR.Add(OPAR87);

			DebugLocation(208, 24);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:208:24: ( typefields )?
			int alt22=2;
			try { DebugEnterSubRule(22);
			try { DebugEnterDecision(22, false);
			int LA22_0 = input.LA(1);

			if ((LA22_0==ID))
			{
				alt22 = 1;
			}
			} finally { DebugExitDecision(22); }
			switch (alt22)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:208:24: typefields
				{
				DebugLocation(208, 24);
				PushFollow(Follow._typefields_in_funcdec1460);
				typefields88=typefields();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_typefields.Add(typefields88.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(22); }

			DebugLocation(208, 36);
			CPAR89=(IToken)Match(input,CPAR,Follow._CPAR_in_funcdec1463); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_CPAR.Add(CPAR89);

			DebugLocation(208, 41);
			PushFollow(Follow._procOrfunc_in_funcdec1465);
			procOrfunc90=procOrfunc();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_procOrfunc.Add(procOrfunc90.Tree);


			{
			// AST REWRITE
			// elements: ID, typefields, procOrfunc
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 209:3: -> ^( FUNCDEC ID ( typefields )? procOrfunc )
			{
				DebugLocation(209, 6);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:209:6: ^( FUNCDEC ID ( typefields )? procOrfunc )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(209, 8);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(FUNCDEC, "FUNCDEC"), root_1);

				DebugLocation(209, 16);
				adaptor.AddChild(root_1, stream_ID.NextNode());
				DebugLocation(209, 19);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:209:19: ( typefields )?
				if (stream_typefields.HasNext)
				{
					DebugLocation(209, 19);
					adaptor.AddChild(root_1, stream_typefields.NextTree());

				}
				stream_typefields.Reset();
				DebugLocation(209, 31);
				adaptor.AddChild(root_1, stream_procOrfunc.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("funcdec", 19);
			LeaveRule("funcdec", 19);
			LeaveRule_funcdec();
		}
		DebugLocation(209, 41);
		} finally { DebugExitRule(GrammarFileName, "funcdec"); }
		return retval;

	}
	// $ANTLR end "funcdec"

	partial void EnterRule_procOrfunc();
	partial void LeaveRule_procOrfunc();

	// $ANTLR start "procOrfunc"
	// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:212:1: procOrfunc : ( COLON ( ID | TYPE ) EQ exp -> ^( FUNC ( ID )? ( TYPE )? exp ) | EQ exp -> ^( PROC exp ) );
	[GrammarRule("procOrfunc")]
	private AstParserRuleReturnScope<object, IToken> procOrfunc()
	{
		EnterRule_procOrfunc();
		EnterRule("procOrfunc", 20);
		TraceIn("procOrfunc", 20);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken COLON91 = default(IToken);
		IToken ID92 = default(IToken);
		IToken TYPE93 = default(IToken);
		IToken EQ94 = default(IToken);
		IToken EQ96 = default(IToken);
		AstParserRuleReturnScope<object, IToken> exp95 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> exp97 = default(AstParserRuleReturnScope<object, IToken>);

		object COLON91_tree = default(object);
		object ID92_tree = default(object);
		object TYPE93_tree = default(object);
		object EQ94_tree = default(object);
		object EQ96_tree = default(object);
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleITokenStream stream_EQ=new RewriteRuleITokenStream(adaptor,"token EQ");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_TYPE=new RewriteRuleITokenStream(adaptor,"token TYPE");
		RewriteRuleSubtreeStream stream_exp=new RewriteRuleSubtreeStream(adaptor,"rule exp");
		try { DebugEnterRule(GrammarFileName, "procOrfunc");
		DebugLocation(212, 24);
		try
		{
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:213:2: ( COLON ( ID | TYPE ) EQ exp -> ^( FUNC ( ID )? ( TYPE )? exp ) | EQ exp -> ^( PROC exp ) )
			int alt24=2;
			try { DebugEnterDecision(24, false);
			int LA24_0 = input.LA(1);

			if ((LA24_0==COLON))
			{
				alt24 = 1;
			}
			else if ((LA24_0==EQ))
			{
				alt24 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 24, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(24); }
			switch (alt24)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:213:4: COLON ( ID | TYPE ) EQ exp
				{
				DebugLocation(213, 4);
				COLON91=(IToken)Match(input,COLON,Follow._COLON_in_procOrfunc1490); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_COLON.Add(COLON91);

				DebugLocation(213, 10);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:213:10: ( ID | TYPE )
				int alt23=2;
				try { DebugEnterSubRule(23);
				try { DebugEnterDecision(23, false);
				int LA23_0 = input.LA(1);

				if ((LA23_0==ID))
				{
					alt23 = 1;
				}
				else if ((LA23_0==TYPE))
				{
					alt23 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 23, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(23); }
				switch (alt23)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:213:11: ID
					{
					DebugLocation(213, 11);
					ID92=(IToken)Match(input,ID,Follow._ID_in_procOrfunc1493); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_ID.Add(ID92);


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:213:16: TYPE
					{
					DebugLocation(213, 16);
					TYPE93=(IToken)Match(input,TYPE,Follow._TYPE_in_procOrfunc1497); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_TYPE.Add(TYPE93);


					}
					break;

				}
				} finally { DebugExitSubRule(23); }

				DebugLocation(213, 22);
				EQ94=(IToken)Match(input,EQ,Follow._EQ_in_procOrfunc1500); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_EQ.Add(EQ94);

				DebugLocation(213, 25);
				PushFollow(Follow._exp_in_procOrfunc1502);
				exp95=exp();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_exp.Add(exp95.Tree);


				{
				// AST REWRITE
				// elements: TYPE, exp, ID
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 213:29: -> ^( FUNC ( ID )? ( TYPE )? exp )
				{
					DebugLocation(213, 32);
					// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:213:32: ^( FUNC ( ID )? ( TYPE )? exp )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(213, 34);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(FUNC, "FUNC"), root_1);

					DebugLocation(213, 39);
					// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:213:39: ( ID )?
					if (stream_ID.HasNext)
					{
						DebugLocation(213, 39);
						adaptor.AddChild(root_1, stream_ID.NextNode());

					}
					stream_ID.Reset();
					DebugLocation(213, 43);
					// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:213:43: ( TYPE )?
					if (stream_TYPE.HasNext)
					{
						DebugLocation(213, 43);
						adaptor.AddChild(root_1, stream_TYPE.NextNode());

					}
					stream_TYPE.Reset();
					DebugLocation(213, 49);
					adaptor.AddChild(root_1, stream_exp.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:214:4: EQ exp
				{
				DebugLocation(214, 4);
				EQ96=(IToken)Match(input,EQ,Follow._EQ_in_procOrfunc1522); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_EQ.Add(EQ96);

				DebugLocation(214, 7);
				PushFollow(Follow._exp_in_procOrfunc1524);
				exp97=exp();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_exp.Add(exp97.Tree);


				{
				// AST REWRITE
				// elements: exp
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 214:11: -> ^( PROC exp )
				{
					DebugLocation(214, 14);
					// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:214:14: ^( PROC exp )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(214, 16);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(PROC, "PROC"), root_1);

					DebugLocation(214, 21);
					adaptor.AddChild(root_1, stream_exp.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("procOrfunc", 20);
			LeaveRule("procOrfunc", 20);
			LeaveRule_procOrfunc();
		}
		DebugLocation(214, 24);
		} finally { DebugExitRule(GrammarFileName, "procOrfunc"); }
		return retval;

	}
	// $ANTLR end "procOrfunc"

	partial void EnterRule_vardec();
	partial void LeaveRule_vardec();

	// $ANTLR start "vardec"
	// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:217:1: vardec : VAR ID ( COLON ( ID | TYPE ) )? ASSIGN exp -> ^( VAR ID ( ID )? ( TYPE )? exp ) ;
	[GrammarRule("vardec")]
	private AstParserRuleReturnScope<object, IToken> vardec()
	{
		EnterRule_vardec();
		EnterRule("vardec", 21);
		TraceIn("vardec", 21);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken VAR98 = default(IToken);
		IToken ID99 = default(IToken);
		IToken COLON100 = default(IToken);
		IToken ID101 = default(IToken);
		IToken TYPE102 = default(IToken);
		IToken ASSIGN103 = default(IToken);
		AstParserRuleReturnScope<object, IToken> exp104 = default(AstParserRuleReturnScope<object, IToken>);

		object VAR98_tree = default(object);
		object ID99_tree = default(object);
		object COLON100_tree = default(object);
		object ID101_tree = default(object);
		object TYPE102_tree = default(object);
		object ASSIGN103_tree = default(object);
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleITokenStream stream_VAR=new RewriteRuleITokenStream(adaptor,"token VAR");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_TYPE=new RewriteRuleITokenStream(adaptor,"token TYPE");
		RewriteRuleITokenStream stream_ASSIGN=new RewriteRuleITokenStream(adaptor,"token ASSIGN");
		RewriteRuleSubtreeStream stream_exp=new RewriteRuleSubtreeStream(adaptor,"rule exp");
		try { DebugEnterRule(GrammarFileName, "vardec");
		DebugLocation(217, 28);
		try
		{
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:217:9: ( VAR ID ( COLON ( ID | TYPE ) )? ASSIGN exp -> ^( VAR ID ( ID )? ( TYPE )? exp ) )
			DebugEnterAlt(1);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:217:11: VAR ID ( COLON ( ID | TYPE ) )? ASSIGN exp
			{
			DebugLocation(217, 11);
			VAR98=(IToken)Match(input,VAR,Follow._VAR_in_vardec1542); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_VAR.Add(VAR98);

			DebugLocation(217, 15);
			ID99=(IToken)Match(input,ID,Follow._ID_in_vardec1544); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(ID99);

			DebugLocation(217, 18);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:217:18: ( COLON ( ID | TYPE ) )?
			int alt26=2;
			try { DebugEnterSubRule(26);
			try { DebugEnterDecision(26, false);
			int LA26_0 = input.LA(1);

			if ((LA26_0==COLON))
			{
				alt26 = 1;
			}
			} finally { DebugExitDecision(26); }
			switch (alt26)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:217:19: COLON ( ID | TYPE )
				{
				DebugLocation(217, 19);
				COLON100=(IToken)Match(input,COLON,Follow._COLON_in_vardec1547); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_COLON.Add(COLON100);

				DebugLocation(217, 25);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:217:25: ( ID | TYPE )
				int alt25=2;
				try { DebugEnterSubRule(25);
				try { DebugEnterDecision(25, false);
				int LA25_0 = input.LA(1);

				if ((LA25_0==ID))
				{
					alt25 = 1;
				}
				else if ((LA25_0==TYPE))
				{
					alt25 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 25, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(25); }
				switch (alt25)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:217:26: ID
					{
					DebugLocation(217, 26);
					ID101=(IToken)Match(input,ID,Follow._ID_in_vardec1550); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_ID.Add(ID101);


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:217:31: TYPE
					{
					DebugLocation(217, 31);
					TYPE102=(IToken)Match(input,TYPE,Follow._TYPE_in_vardec1554); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_TYPE.Add(TYPE102);


					}
					break;

				}
				} finally { DebugExitSubRule(25); }


				}
				break;

			}
			} finally { DebugExitSubRule(26); }

			DebugLocation(217, 39);
			ASSIGN103=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_vardec1559); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ASSIGN.Add(ASSIGN103);

			DebugLocation(217, 46);
			PushFollow(Follow._exp_in_vardec1561);
			exp104=exp();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_exp.Add(exp104.Tree);


			{
			// AST REWRITE
			// elements: VAR, ID, ID, exp, TYPE
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 218:3: -> ^( VAR ID ( ID )? ( TYPE )? exp )
			{
				DebugLocation(218, 6);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:218:6: ^( VAR ID ( ID )? ( TYPE )? exp )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(218, 8);
				root_1 = (object)adaptor.BecomeRoot(stream_VAR.NextNode(), root_1);

				DebugLocation(218, 12);
				adaptor.AddChild(root_1, stream_ID.NextNode());
				DebugLocation(218, 15);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:218:15: ( ID )?
				if (stream_ID.HasNext)
				{
					DebugLocation(218, 15);
					adaptor.AddChild(root_1, stream_ID.NextNode());

				}
				stream_ID.Reset();
				DebugLocation(218, 19);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:218:19: ( TYPE )?
				if (stream_TYPE.HasNext)
				{
					DebugLocation(218, 19);
					adaptor.AddChild(root_1, stream_TYPE.NextNode());

				}
				stream_TYPE.Reset();
				DebugLocation(218, 25);
				adaptor.AddChild(root_1, stream_exp.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("vardec", 21);
			LeaveRule("vardec", 21);
			LeaveRule_vardec();
		}
		DebugLocation(218, 28);
		} finally { DebugExitRule(GrammarFileName, "vardec"); }
		return retval;

	}
	// $ANTLR end "vardec"

	partial void EnterRule_for();
	partial void LeaveRule_for();

	// $ANTLR start "for"
	// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:220:1: for : FOR ID ASSIGN exp TO exp DO exp -> ^( FOR ID exp exp exp ) ;
	[GrammarRule("for")]
	private AstParserRuleReturnScope<object, IToken> @for()
	{
		EnterRule_for();
		EnterRule("for", 22);
		TraceIn("for", 22);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken FOR105 = default(IToken);
		IToken ID106 = default(IToken);
		IToken ASSIGN107 = default(IToken);
		IToken TO109 = default(IToken);
		IToken DO111 = default(IToken);
		AstParserRuleReturnScope<object, IToken> exp108 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> exp110 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> exp112 = default(AstParserRuleReturnScope<object, IToken>);

		object FOR105_tree = default(object);
		object ID106_tree = default(object);
		object ASSIGN107_tree = default(object);
		object TO109_tree = default(object);
		object DO111_tree = default(object);
		RewriteRuleITokenStream stream_FOR=new RewriteRuleITokenStream(adaptor,"token FOR");
		RewriteRuleITokenStream stream_DO=new RewriteRuleITokenStream(adaptor,"token DO");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_TO=new RewriteRuleITokenStream(adaptor,"token TO");
		RewriteRuleITokenStream stream_ASSIGN=new RewriteRuleITokenStream(adaptor,"token ASSIGN");
		RewriteRuleSubtreeStream stream_exp=new RewriteRuleSubtreeStream(adaptor,"rule exp");
		try { DebugEnterRule(GrammarFileName, "for");
		DebugLocation(220, 26);
		try
		{
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:220:5: ( FOR ID ASSIGN exp TO exp DO exp -> ^( FOR ID exp exp exp ) )
			DebugEnterAlt(1);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:220:7: FOR ID ASSIGN exp TO exp DO exp
			{
			DebugLocation(220, 7);
			FOR105=(IToken)Match(input,FOR,Follow._FOR_in_for1587); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_FOR.Add(FOR105);

			DebugLocation(220, 11);
			ID106=(IToken)Match(input,ID,Follow._ID_in_for1589); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(ID106);

			DebugLocation(220, 14);
			ASSIGN107=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_for1591); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ASSIGN.Add(ASSIGN107);

			DebugLocation(220, 21);
			PushFollow(Follow._exp_in_for1593);
			exp108=exp();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_exp.Add(exp108.Tree);
			DebugLocation(220, 25);
			TO109=(IToken)Match(input,TO,Follow._TO_in_for1595); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_TO.Add(TO109);

			DebugLocation(220, 28);
			PushFollow(Follow._exp_in_for1597);
			exp110=exp();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_exp.Add(exp110.Tree);
			DebugLocation(220, 32);
			DO111=(IToken)Match(input,DO,Follow._DO_in_for1599); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_DO.Add(DO111);

			DebugLocation(220, 35);
			PushFollow(Follow._exp_in_for1601);
			exp112=exp();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_exp.Add(exp112.Tree);


			{
			// AST REWRITE
			// elements: exp, ID, exp, exp, FOR
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 221:3: -> ^( FOR ID exp exp exp )
			{
				DebugLocation(221, 6);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:221:6: ^( FOR ID exp exp exp )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(221, 8);
				root_1 = (object)adaptor.BecomeRoot(stream_FOR.NextNode(), root_1);

				DebugLocation(221, 12);
				adaptor.AddChild(root_1, stream_ID.NextNode());
				DebugLocation(221, 15);
				adaptor.AddChild(root_1, stream_exp.NextTree());
				DebugLocation(221, 19);
				adaptor.AddChild(root_1, stream_exp.NextTree());
				DebugLocation(221, 23);
				adaptor.AddChild(root_1, stream_exp.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("for", 22);
			LeaveRule("for", 22);
			LeaveRule_for();
		}
		DebugLocation(221, 26);
		} finally { DebugExitRule(GrammarFileName, "for"); }
		return retval;

	}
	// $ANTLR end "for"

	partial void EnterRule_while();
	partial void LeaveRule_while();

	// $ANTLR start "while"
	// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:223:1: while : WHILE exp DO exp -> ^( WHILE exp exp ) ;
	[GrammarRule("while")]
	private AstParserRuleReturnScope<object, IToken> @while()
	{
		EnterRule_while();
		EnterRule("while", 23);
		TraceIn("while", 23);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken WHILE113 = default(IToken);
		IToken DO115 = default(IToken);
		AstParserRuleReturnScope<object, IToken> exp114 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> exp116 = default(AstParserRuleReturnScope<object, IToken>);

		object WHILE113_tree = default(object);
		object DO115_tree = default(object);
		RewriteRuleITokenStream stream_DO=new RewriteRuleITokenStream(adaptor,"token DO");
		RewriteRuleITokenStream stream_WHILE=new RewriteRuleITokenStream(adaptor,"token WHILE");
		RewriteRuleSubtreeStream stream_exp=new RewriteRuleSubtreeStream(adaptor,"rule exp");
		try { DebugEnterRule(GrammarFileName, "while");
		DebugLocation(223, 21);
		try
		{
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:223:7: ( WHILE exp DO exp -> ^( WHILE exp exp ) )
			DebugEnterAlt(1);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:223:9: WHILE exp DO exp
			{
			DebugLocation(223, 9);
			WHILE113=(IToken)Match(input,WHILE,Follow._WHILE_in_while1625); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_WHILE.Add(WHILE113);

			DebugLocation(223, 15);
			PushFollow(Follow._exp_in_while1627);
			exp114=exp();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_exp.Add(exp114.Tree);
			DebugLocation(223, 19);
			DO115=(IToken)Match(input,DO,Follow._DO_in_while1629); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_DO.Add(DO115);

			DebugLocation(223, 22);
			PushFollow(Follow._exp_in_while1631);
			exp116=exp();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_exp.Add(exp116.Tree);


			{
			// AST REWRITE
			// elements: WHILE, exp, exp
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 224:3: -> ^( WHILE exp exp )
			{
				DebugLocation(224, 6);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:224:6: ^( WHILE exp exp )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(224, 8);
				root_1 = (object)adaptor.BecomeRoot(stream_WHILE.NextNode(), root_1);

				DebugLocation(224, 14);
				adaptor.AddChild(root_1, stream_exp.NextTree());
				DebugLocation(224, 18);
				adaptor.AddChild(root_1, stream_exp.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("while", 23);
			LeaveRule("while", 23);
			LeaveRule_while();
		}
		DebugLocation(224, 21);
		} finally { DebugExitRule(GrammarFileName, "while"); }
		return retval;

	}
	// $ANTLR end "while"

	partial void EnterRule_ifthen();
	partial void LeaveRule_ifthen();

	// $ANTLR start "ifthen"
	// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:226:1: ifthen : IF exp THEN exp ( ELSE exp )? -> ^( IF exp exp ( exp )? ) ;
	[GrammarRule("ifthen")]
	private AstParserRuleReturnScope<object, IToken> ifthen()
	{
		EnterRule_ifthen();
		EnterRule("ifthen", 24);
		TraceIn("ifthen", 24);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken IF117 = default(IToken);
		IToken THEN119 = default(IToken);
		IToken ELSE121 = default(IToken);
		AstParserRuleReturnScope<object, IToken> exp118 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> exp120 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> exp122 = default(AstParserRuleReturnScope<object, IToken>);

		object IF117_tree = default(object);
		object THEN119_tree = default(object);
		object ELSE121_tree = default(object);
		RewriteRuleITokenStream stream_THEN=new RewriteRuleITokenStream(adaptor,"token THEN");
		RewriteRuleITokenStream stream_IF=new RewriteRuleITokenStream(adaptor,"token IF");
		RewriteRuleITokenStream stream_ELSE=new RewriteRuleITokenStream(adaptor,"token ELSE");
		RewriteRuleSubtreeStream stream_exp=new RewriteRuleSubtreeStream(adaptor,"rule exp");
		try { DebugEnterRule(GrammarFileName, "ifthen");
		DebugLocation(226, 25);
		try
		{
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:226:8: ( IF exp THEN exp ( ELSE exp )? -> ^( IF exp exp ( exp )? ) )
			DebugEnterAlt(1);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:226:10: IF exp THEN exp ( ELSE exp )?
			{
			DebugLocation(226, 10);
			IF117=(IToken)Match(input,IF,Follow._IF_in_ifthen1651); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_IF.Add(IF117);

			DebugLocation(226, 13);
			PushFollow(Follow._exp_in_ifthen1653);
			exp118=exp();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_exp.Add(exp118.Tree);
			DebugLocation(226, 17);
			THEN119=(IToken)Match(input,THEN,Follow._THEN_in_ifthen1655); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_THEN.Add(THEN119);

			DebugLocation(226, 22);
			PushFollow(Follow._exp_in_ifthen1657);
			exp120=exp();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_exp.Add(exp120.Tree);
			DebugLocation(226, 26);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:226:26: ( ELSE exp )?
			int alt27=2;
			try { DebugEnterSubRule(27);
			try { DebugEnterDecision(27, false);
			int LA27_0 = input.LA(1);

			if ((LA27_0==ELSE))
			{
				int LA27_1 = input.LA(2);

				if ((EvaluatePredicate(synpred48_tiger_fragment)))
				{
					alt27 = 1;
				}
			}
			} finally { DebugExitDecision(27); }
			switch (alt27)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:226:28: ELSE exp
				{
				DebugLocation(226, 28);
				ELSE121=(IToken)Match(input,ELSE,Follow._ELSE_in_ifthen1661); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ELSE.Add(ELSE121);

				DebugLocation(226, 33);
				PushFollow(Follow._exp_in_ifthen1663);
				exp122=exp();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_exp.Add(exp122.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(27); }



			{
			// AST REWRITE
			// elements: exp, exp, IF, exp
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 227:3: -> ^( IF exp exp ( exp )? )
			{
				DebugLocation(227, 6);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:227:6: ^( IF exp exp ( exp )? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(227, 8);
				root_1 = (object)adaptor.BecomeRoot(stream_IF.NextNode(), root_1);

				DebugLocation(227, 11);
				adaptor.AddChild(root_1, stream_exp.NextTree());
				DebugLocation(227, 15);
				adaptor.AddChild(root_1, stream_exp.NextTree());
				DebugLocation(227, 19);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:227:19: ( exp )?
				if (stream_exp.HasNext)
				{
					DebugLocation(227, 20);
					adaptor.AddChild(root_1, stream_exp.NextTree());

				}
				stream_exp.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("ifthen", 24);
			LeaveRule("ifthen", 24);
			LeaveRule_ifthen();
		}
		DebugLocation(227, 25);
		} finally { DebugExitRule(GrammarFileName, "ifthen"); }
		return retval;

	}
	// $ANTLR end "ifthen"

	partial void EnterRule_call();
	partial void LeaveRule_call();

	// $ANTLR start "call"
	// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:229:1: call : OPAR ( explist )? CPAR -> ^( CALL ( explist )? ) ;
	[GrammarRule("call")]
	private AstParserRuleReturnScope<object, IToken> call()
	{
		EnterRule_call();
		EnterRule("call", 25);
		TraceIn("call", 25);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken OPAR123 = default(IToken);
		IToken CPAR125 = default(IToken);
		AstParserRuleReturnScope<object, IToken> explist124 = default(AstParserRuleReturnScope<object, IToken>);

		object OPAR123_tree = default(object);
		object CPAR125_tree = default(object);
		RewriteRuleITokenStream stream_OPAR=new RewriteRuleITokenStream(adaptor,"token OPAR");
		RewriteRuleITokenStream stream_CPAR=new RewriteRuleITokenStream(adaptor,"token CPAR");
		RewriteRuleSubtreeStream stream_explist=new RewriteRuleSubtreeStream(adaptor,"rule explist");
		try { DebugEnterRule(GrammarFileName, "call");
		DebugLocation(229, 45);
		try
		{
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:229:6: ( OPAR ( explist )? CPAR -> ^( CALL ( explist )? ) )
			DebugEnterAlt(1);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:229:8: OPAR ( explist )? CPAR
			{
			DebugLocation(229, 8);
			OPAR123=(IToken)Match(input,OPAR,Follow._OPAR_in_call1690); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_OPAR.Add(OPAR123);

			DebugLocation(229, 13);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:229:13: ( explist )?
			int alt28=2;
			try { DebugEnterSubRule(28);
			try { DebugEnterDecision(28, false);
			int LA28_0 = input.LA(1);

			if ((LA28_0==BREAK||LA28_0==FOR||LA28_0==ID||LA28_0==IF||(LA28_0>=INT && LA28_0<=LET)||LA28_0==MINUS||LA28_0==NIL||LA28_0==OPAR||LA28_0==STRING||LA28_0==WHILE))
			{
				alt28 = 1;
			}
			} finally { DebugExitDecision(28); }
			switch (alt28)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:229:13: explist
				{
				DebugLocation(229, 13);
				PushFollow(Follow._explist_in_call1692);
				explist124=explist();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_explist.Add(explist124.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(28); }

			DebugLocation(229, 22);
			CPAR125=(IToken)Match(input,CPAR,Follow._CPAR_in_call1695); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_CPAR.Add(CPAR125);



			{
			// AST REWRITE
			// elements: explist
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 229:27: -> ^( CALL ( explist )? )
			{
				DebugLocation(229, 30);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:229:30: ^( CALL ( explist )? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(229, 32);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(CALL, "CALL"), root_1);

				DebugLocation(229, 37);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:229:37: ( explist )?
				if (stream_explist.HasNext)
				{
					DebugLocation(229, 37);
					adaptor.AddChild(root_1, stream_explist.NextTree());

				}
				stream_explist.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("call", 25);
			LeaveRule("call", 25);
			LeaveRule_call();
		}
		DebugLocation(229, 45);
		} finally { DebugExitRule(GrammarFileName, "call"); }
		return retval;

	}
	// $ANTLR end "call"

	partial void EnterRule_assign();
	partial void LeaveRule_assign();

	// $ANTLR start "assign"
	// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:232:1: assign : ASSIGN exp -> ^( ASSIGN exp ) ;
	[GrammarRule("assign")]
	private AstParserRuleReturnScope<object, IToken> assign()
	{
		EnterRule_assign();
		EnterRule("assign", 26);
		TraceIn("assign", 26);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ASSIGN126 = default(IToken);
		AstParserRuleReturnScope<object, IToken> exp127 = default(AstParserRuleReturnScope<object, IToken>);

		object ASSIGN126_tree = default(object);
		RewriteRuleITokenStream stream_ASSIGN=new RewriteRuleITokenStream(adaptor,"token ASSIGN");
		RewriteRuleSubtreeStream stream_exp=new RewriteRuleSubtreeStream(adaptor,"rule exp");
		try { DebugEnterRule(GrammarFileName, "assign");
		DebugLocation(232, 36);
		try
		{
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:232:8: ( ASSIGN exp -> ^( ASSIGN exp ) )
			DebugEnterAlt(1);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:232:10: ASSIGN exp
			{
			DebugLocation(232, 10);
			ASSIGN126=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_assign1714); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ASSIGN.Add(ASSIGN126);

			DebugLocation(232, 17);
			PushFollow(Follow._exp_in_assign1716);
			exp127=exp();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_exp.Add(exp127.Tree);


			{
			// AST REWRITE
			// elements: ASSIGN, exp
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 232:21: -> ^( ASSIGN exp )
			{
				DebugLocation(232, 24);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:232:24: ^( ASSIGN exp )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(232, 26);
				root_1 = (object)adaptor.BecomeRoot(stream_ASSIGN.NextNode(), root_1);

				DebugLocation(232, 33);
				adaptor.AddChild(root_1, stream_exp.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("assign", 26);
			LeaveRule("assign", 26);
			LeaveRule_assign();
		}
		DebugLocation(232, 36);
		} finally { DebugExitRule(GrammarFileName, "assign"); }
		return retval;

	}
	// $ANTLR end "assign"

	partial void EnterRule_lvalue();
	partial void LeaveRule_lvalue();

	// $ANTLR start "lvalue"
	// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:234:1: lvalue : ( arrayAccess | idAccess )+ ;
	[GrammarRule("lvalue")]
	private AstParserRuleReturnScope<object, IToken> lvalue()
	{
		EnterRule_lvalue();
		EnterRule("lvalue", 27);
		TraceIn("lvalue", 27);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> arrayAccess128 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> idAccess129 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "lvalue");
		DebugLocation(234, 36);
		try
		{
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:234:9: ( ( arrayAccess | idAccess )+ )
			DebugEnterAlt(1);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:234:11: ( arrayAccess | idAccess )+
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(234, 11);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:234:11: ( arrayAccess | idAccess )+
			int cnt29=0;
			try { DebugEnterSubRule(29);
			while (true)
			{
				int alt29=3;
				try { DebugEnterDecision(29, false);
				int LA29_0 = input.LA(1);

				if ((LA29_0==OBRACK))
				{
					alt29 = 1;
				}
				else if ((LA29_0==DOT))
				{
					alt29 = 2;
				}


				} finally { DebugExitDecision(29); }
				switch (alt29)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:234:12: arrayAccess
					{
					DebugLocation(234, 12);
					PushFollow(Follow._arrayAccess_in_lvalue1734);
					arrayAccess128=arrayAccess();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, arrayAccess128.Tree);

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:234:26: idAccess
					{
					DebugLocation(234, 26);
					PushFollow(Follow._idAccess_in_lvalue1738);
					idAccess129=idAccess();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, idAccess129.Tree);

					}
					break;

				default:
					if (cnt29 >= 1)
						goto loop29;

					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee29 = new EarlyExitException( 29, input );
					DebugRecognitionException(eee29);
					throw eee29;
				}
				cnt29++;
			}
			loop29:
				;

			} finally { DebugExitSubRule(29); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("lvalue", 27);
			LeaveRule("lvalue", 27);
			LeaveRule_lvalue();
		}
		DebugLocation(234, 36);
		} finally { DebugExitRule(GrammarFileName, "lvalue"); }
		return retval;

	}
	// $ANTLR end "lvalue"

	partial void EnterRule_arrayAccess();
	partial void LeaveRule_arrayAccess();

	// $ANTLR start "arrayAccess"
	// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:236:1: arrayAccess : OBRACK exp CBRACK -> ^( AACCESS exp ) ;
	[GrammarRule("arrayAccess")]
	private AstParserRuleReturnScope<object, IToken> arrayAccess()
	{
		EnterRule_arrayAccess();
		EnterRule("arrayAccess", 28);
		TraceIn("arrayAccess", 28);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken OBRACK130 = default(IToken);
		IToken CBRACK132 = default(IToken);
		AstParserRuleReturnScope<object, IToken> exp131 = default(AstParserRuleReturnScope<object, IToken>);

		object OBRACK130_tree = default(object);
		object CBRACK132_tree = default(object);
		RewriteRuleITokenStream stream_OBRACK=new RewriteRuleITokenStream(adaptor,"token OBRACK");
		RewriteRuleITokenStream stream_CBRACK=new RewriteRuleITokenStream(adaptor,"token CBRACK");
		RewriteRuleSubtreeStream stream_exp=new RewriteRuleSubtreeStream(adaptor,"rule exp");
		try { DebugEnterRule(GrammarFileName, "arrayAccess");
		DebugLocation(236, 49);
		try
		{
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:236:13: ( OBRACK exp CBRACK -> ^( AACCESS exp ) )
			DebugEnterAlt(1);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:236:15: OBRACK exp CBRACK
			{
			DebugLocation(236, 15);
			OBRACK130=(IToken)Match(input,OBRACK,Follow._OBRACK_in_arrayAccess1750); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_OBRACK.Add(OBRACK130);

			DebugLocation(236, 22);
			PushFollow(Follow._exp_in_arrayAccess1752);
			exp131=exp();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_exp.Add(exp131.Tree);
			DebugLocation(236, 26);
			CBRACK132=(IToken)Match(input,CBRACK,Follow._CBRACK_in_arrayAccess1754); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_CBRACK.Add(CBRACK132);



			{
			// AST REWRITE
			// elements: exp
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 236:33: -> ^( AACCESS exp )
			{
				DebugLocation(236, 36);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:236:36: ^( AACCESS exp )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(236, 38);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(AACCESS, "AACCESS"), root_1);

				DebugLocation(236, 46);
				adaptor.AddChild(root_1, stream_exp.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("arrayAccess", 28);
			LeaveRule("arrayAccess", 28);
			LeaveRule_arrayAccess();
		}
		DebugLocation(236, 49);
		} finally { DebugExitRule(GrammarFileName, "arrayAccess"); }
		return retval;

	}
	// $ANTLR end "arrayAccess"

	partial void EnterRule_idAccess();
	partial void LeaveRule_idAccess();

	// $ANTLR start "idAccess"
	// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:238:1: idAccess : DOT ID -> ^( IDACCESS ID ) ;
	[GrammarRule("idAccess")]
	private AstParserRuleReturnScope<object, IToken> idAccess()
	{
		EnterRule_idAccess();
		EnterRule("idAccess", 29);
		TraceIn("idAccess", 29);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken DOT133 = default(IToken);
		IToken ID134 = default(IToken);

		object DOT133_tree = default(object);
		object ID134_tree = default(object);
		RewriteRuleITokenStream stream_DOT=new RewriteRuleITokenStream(adaptor,"token DOT");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		try { DebugEnterRule(GrammarFileName, "idAccess");
		DebugLocation(238, 35);
		try
		{
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:238:10: ( DOT ID -> ^( IDACCESS ID ) )
			DebugEnterAlt(1);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:238:12: DOT ID
			{
			DebugLocation(238, 12);
			DOT133=(IToken)Match(input,DOT,Follow._DOT_in_idAccess1771); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_DOT.Add(DOT133);

			DebugLocation(238, 16);
			ID134=(IToken)Match(input,ID,Follow._ID_in_idAccess1773); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(ID134);



			{
			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 238:19: -> ^( IDACCESS ID )
			{
				DebugLocation(238, 22);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:238:22: ^( IDACCESS ID )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(238, 24);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(IDACCESS, "IDACCESS"), root_1);

				DebugLocation(238, 33);
				adaptor.AddChild(root_1, stream_ID.NextNode());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("idAccess", 29);
			LeaveRule("idAccess", 29);
			LeaveRule_idAccess();
		}
		DebugLocation(238, 35);
		} finally { DebugExitRule(GrammarFileName, "idAccess"); }
		return retval;

	}
	// $ANTLR end "idAccess"

	partial void EnterRule_expseq();
	partial void LeaveRule_expseq();

	// $ANTLR start "expseq"
	// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:240:1: expseq : exp ( SMCOL exp )* -> exp ( exp )* ;
	[GrammarRule("expseq")]
	private AstParserRuleReturnScope<object, IToken> expseq()
	{
		EnterRule_expseq();
		EnterRule("expseq", 30);
		TraceIn("expseq", 30);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken SMCOL136 = default(IToken);
		AstParserRuleReturnScope<object, IToken> exp135 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> exp137 = default(AstParserRuleReturnScope<object, IToken>);

		object SMCOL136_tree = default(object);
		RewriteRuleITokenStream stream_SMCOL=new RewriteRuleITokenStream(adaptor,"token SMCOL");
		RewriteRuleSubtreeStream stream_exp=new RewriteRuleSubtreeStream(adaptor,"rule exp");
		try { DebugEnterRule(GrammarFileName, "expseq");
		DebugLocation(240, 39);
		try
		{
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:240:8: ( exp ( SMCOL exp )* -> exp ( exp )* )
			DebugEnterAlt(1);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:240:10: exp ( SMCOL exp )*
			{
			DebugLocation(240, 10);
			PushFollow(Follow._exp_in_expseq1789);
			exp135=exp();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_exp.Add(exp135.Tree);
			DebugLocation(240, 14);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:240:14: ( SMCOL exp )*
			try { DebugEnterSubRule(30);
			while (true)
			{
				int alt30=2;
				try { DebugEnterDecision(30, false);
				int LA30_0 = input.LA(1);

				if ((LA30_0==SMCOL))
				{
					alt30 = 1;
				}


				} finally { DebugExitDecision(30); }
				switch ( alt30 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:240:15: SMCOL exp
					{
					DebugLocation(240, 15);
					SMCOL136=(IToken)Match(input,SMCOL,Follow._SMCOL_in_expseq1792); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_SMCOL.Add(SMCOL136);

					DebugLocation(240, 21);
					PushFollow(Follow._exp_in_expseq1794);
					exp137=exp();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_exp.Add(exp137.Tree);

					}
					break;

				default:
					goto loop30;
				}
			}

			loop30:
				;

			} finally { DebugExitSubRule(30); }



			{
			// AST REWRITE
			// elements: exp, exp
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 240:27: -> exp ( exp )*
			{
				DebugLocation(240, 30);
				adaptor.AddChild(root_0, stream_exp.NextTree());
				DebugLocation(240, 34);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:240:34: ( exp )*
				while ( stream_exp.HasNext )
				{
					DebugLocation(240, 35);
					adaptor.AddChild(root_0, stream_exp.NextTree());

				}
				stream_exp.Reset();

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expseq", 30);
			LeaveRule("expseq", 30);
			LeaveRule_expseq();
		}
		DebugLocation(240, 39);
		} finally { DebugExitRule(GrammarFileName, "expseq"); }
		return retval;

	}
	// $ANTLR end "expseq"

	partial void EnterRule_explist();
	partial void LeaveRule_explist();

	// $ANTLR start "explist"
	// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:242:1: explist : exp ( COMMA exp )* -> ^( EXPLIST exp ( exp )* ) ;
	[GrammarRule("explist")]
	private AstParserRuleReturnScope<object, IToken> explist()
	{
		EnterRule_explist();
		EnterRule("explist", 31);
		TraceIn("explist", 31);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken COMMA139 = default(IToken);
		AstParserRuleReturnScope<object, IToken> exp138 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> exp140 = default(AstParserRuleReturnScope<object, IToken>);

		object COMMA139_tree = default(object);
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_exp=new RewriteRuleSubtreeStream(adaptor,"rule exp");
		try { DebugEnterRule(GrammarFileName, "explist");
		DebugLocation(242, 51);
		try
		{
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:242:9: ( exp ( COMMA exp )* -> ^( EXPLIST exp ( exp )* ) )
			DebugEnterAlt(1);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:242:11: exp ( COMMA exp )*
			{
			DebugLocation(242, 11);
			PushFollow(Follow._exp_in_explist1813);
			exp138=exp();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_exp.Add(exp138.Tree);
			DebugLocation(242, 15);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:242:15: ( COMMA exp )*
			try { DebugEnterSubRule(31);
			while (true)
			{
				int alt31=2;
				try { DebugEnterDecision(31, false);
				int LA31_0 = input.LA(1);

				if ((LA31_0==COMMA))
				{
					alt31 = 1;
				}


				} finally { DebugExitDecision(31); }
				switch ( alt31 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:242:16: COMMA exp
					{
					DebugLocation(242, 16);
					COMMA139=(IToken)Match(input,COMMA,Follow._COMMA_in_explist1816); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_COMMA.Add(COMMA139);

					DebugLocation(242, 22);
					PushFollow(Follow._exp_in_explist1818);
					exp140=exp();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_exp.Add(exp140.Tree);

					}
					break;

				default:
					goto loop31;
				}
			}

			loop31:
				;

			} finally { DebugExitSubRule(31); }



			{
			// AST REWRITE
			// elements: exp, exp
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 242:28: -> ^( EXPLIST exp ( exp )* )
			{
				DebugLocation(242, 31);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:242:31: ^( EXPLIST exp ( exp )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(242, 33);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(EXPLIST, "EXPLIST"), root_1);

				DebugLocation(242, 41);
				adaptor.AddChild(root_1, stream_exp.NextTree());
				DebugLocation(242, 45);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:242:45: ( exp )*
				while ( stream_exp.HasNext )
				{
					DebugLocation(242, 46);
					adaptor.AddChild(root_1, stream_exp.NextTree());

				}
				stream_exp.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("explist", 31);
			LeaveRule("explist", 31);
			LeaveRule_explist();
		}
		DebugLocation(242, 51);
		} finally { DebugExitRule(GrammarFileName, "explist"); }
		return retval;

	}
	// $ANTLR end "explist"

	partial void EnterRule_typefields();
	partial void LeaveRule_typefields();

	// $ANTLR start "typefields"
	// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:250:1: typefields : typefield ( COMMA typefield )* -> ^( TYPEFIELDS typefield ( typefield )* ) ;
	[GrammarRule("typefields")]
	private AstParserRuleReturnScope<object, IToken> typefields()
	{
		EnterRule_typefields();
		EnterRule("typefields", 32);
		TraceIn("typefields", 32);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken COMMA142 = default(IToken);
		AstParserRuleReturnScope<object, IToken> typefield141 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> typefield143 = default(AstParserRuleReturnScope<object, IToken>);

		object COMMA142_tree = default(object);
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_typefield=new RewriteRuleSubtreeStream(adaptor,"rule typefield");
		try { DebugEnterRule(GrammarFileName, "typefields");
		DebugLocation(250, 80);
		try
		{
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:250:11: ( typefield ( COMMA typefield )* -> ^( TYPEFIELDS typefield ( typefield )* ) )
			DebugEnterAlt(1);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:250:13: typefield ( COMMA typefield )*
			{
			DebugLocation(250, 13);
			PushFollow(Follow._typefield_in_typefields1846);
			typefield141=typefield();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_typefield.Add(typefield141.Tree);
			DebugLocation(250, 23);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:250:23: ( COMMA typefield )*
			try { DebugEnterSubRule(32);
			while (true)
			{
				int alt32=2;
				try { DebugEnterDecision(32, false);
				int LA32_0 = input.LA(1);

				if ((LA32_0==COMMA))
				{
					alt32 = 1;
				}


				} finally { DebugExitDecision(32); }
				switch ( alt32 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:250:24: COMMA typefield
					{
					DebugLocation(250, 24);
					COMMA142=(IToken)Match(input,COMMA,Follow._COMMA_in_typefields1849); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_COMMA.Add(COMMA142);

					DebugLocation(250, 30);
					PushFollow(Follow._typefield_in_typefields1851);
					typefield143=typefield();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_typefield.Add(typefield143.Tree);

					}
					break;

				default:
					goto loop32;
				}
			}

			loop32:
				;

			} finally { DebugExitSubRule(32); }



			{
			// AST REWRITE
			// elements: typefield, typefield
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 250:42: -> ^( TYPEFIELDS typefield ( typefield )* )
			{
				DebugLocation(250, 45);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:250:45: ^( TYPEFIELDS typefield ( typefield )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(250, 47);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(TYPEFIELDS, "TYPEFIELDS"), root_1);

				DebugLocation(250, 58);
				adaptor.AddChild(root_1, stream_typefield.NextTree());
				DebugLocation(250, 68);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:250:68: ( typefield )*
				while ( stream_typefield.HasNext )
				{
					DebugLocation(250, 69);
					adaptor.AddChild(root_1, stream_typefield.NextTree());

				}
				stream_typefield.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("typefields", 32);
			LeaveRule("typefields", 32);
			LeaveRule_typefields();
		}
		DebugLocation(250, 80);
		} finally { DebugExitRule(GrammarFileName, "typefields"); }
		return retval;

	}
	// $ANTLR end "typefields"

	partial void EnterRule_typefield();
	partial void LeaveRule_typefield();

	// $ANTLR start "typefield"
	// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:252:1: typefield : ID COLON ( TYPE | ID ) -> ^( TYPEFIELD ID ( ID )? ( TYPE )? ) ;
	[GrammarRule("typefield")]
	private AstParserRuleReturnScope<object, IToken> typefield()
	{
		EnterRule_typefield();
		EnterRule("typefield", 33);
		TraceIn("typefield", 33);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID144 = default(IToken);
		IToken COLON145 = default(IToken);
		IToken TYPE146 = default(IToken);
		IToken ID147 = default(IToken);

		object ID144_tree = default(object);
		object COLON145_tree = default(object);
		object TYPE146_tree = default(object);
		object ID147_tree = default(object);
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_TYPE=new RewriteRuleITokenStream(adaptor,"token TYPE");
		try { DebugEnterRule(GrammarFileName, "typefield");
		DebugLocation(252, 59);
		try
		{
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:252:10: ( ID COLON ( TYPE | ID ) -> ^( TYPEFIELD ID ( ID )? ( TYPE )? ) )
			DebugEnterAlt(1);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:252:12: ID COLON ( TYPE | ID )
			{
			DebugLocation(252, 12);
			ID144=(IToken)Match(input,ID,Follow._ID_in_typefield1873); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(ID144);

			DebugLocation(252, 15);
			COLON145=(IToken)Match(input,COLON,Follow._COLON_in_typefield1875); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_COLON.Add(COLON145);

			DebugLocation(252, 21);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:252:21: ( TYPE | ID )
			int alt33=2;
			try { DebugEnterSubRule(33);
			try { DebugEnterDecision(33, false);
			int LA33_0 = input.LA(1);

			if ((LA33_0==TYPE))
			{
				alt33 = 1;
			}
			else if ((LA33_0==ID))
			{
				alt33 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 33, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(33); }
			switch (alt33)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:252:22: TYPE
				{
				DebugLocation(252, 22);
				TYPE146=(IToken)Match(input,TYPE,Follow._TYPE_in_typefield1878); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_TYPE.Add(TYPE146);


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:252:29: ID
				{
				DebugLocation(252, 29);
				ID147=(IToken)Match(input,ID,Follow._ID_in_typefield1882); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(ID147);


				}
				break;

			}
			} finally { DebugExitSubRule(33); }



			{
			// AST REWRITE
			// elements: ID, TYPE, ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 252:32: -> ^( TYPEFIELD ID ( ID )? ( TYPE )? )
			{
				DebugLocation(252, 35);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:252:35: ^( TYPEFIELD ID ( ID )? ( TYPE )? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(252, 37);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(TYPEFIELD, "TYPEFIELD"), root_1);

				DebugLocation(252, 47);
				adaptor.AddChild(root_1, stream_ID.NextNode());
				DebugLocation(252, 50);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:252:50: ( ID )?
				if (stream_ID.HasNext)
				{
					DebugLocation(252, 50);
					adaptor.AddChild(root_1, stream_ID.NextNode());

				}
				stream_ID.Reset();
				DebugLocation(252, 54);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:252:54: ( TYPE )?
				if (stream_TYPE.HasNext)
				{
					DebugLocation(252, 54);
					adaptor.AddChild(root_1, stream_TYPE.NextNode());

				}
				stream_TYPE.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("typefield", 33);
			LeaveRule("typefield", 33);
			LeaveRule_typefield();
		}
		DebugLocation(252, 59);
		} finally { DebugExitRule(GrammarFileName, "typefield"); }
		return retval;

	}
	// $ANTLR end "typefield"

	partial void EnterRule_fieldlist();
	partial void LeaveRule_fieldlist();

	// $ANTLR start "fieldlist"
	// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:254:1: fieldlist : field ( COMMA field )* -> ^( FIELDLIST field ( field )* ) ;
	[GrammarRule("fieldlist")]
	private AstParserRuleReturnScope<object, IToken> fieldlist()
	{
		EnterRule_fieldlist();
		EnterRule("fieldlist", 34);
		TraceIn("fieldlist", 34);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken COMMA149 = default(IToken);
		AstParserRuleReturnScope<object, IToken> field148 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> field150 = default(AstParserRuleReturnScope<object, IToken>);

		object COMMA149_tree = default(object);
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_field=new RewriteRuleSubtreeStream(adaptor,"rule field");
		try { DebugEnterRule(GrammarFileName, "fieldlist");
		DebugLocation(254, 63);
		try
		{
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:254:11: ( field ( COMMA field )* -> ^( FIELDLIST field ( field )* ) )
			DebugEnterAlt(1);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:254:13: field ( COMMA field )*
			{
			DebugLocation(254, 13);
			PushFollow(Follow._field_in_fieldlist1904);
			field148=field();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_field.Add(field148.Tree);
			DebugLocation(254, 19);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:254:19: ( COMMA field )*
			try { DebugEnterSubRule(34);
			while (true)
			{
				int alt34=2;
				try { DebugEnterDecision(34, false);
				int LA34_0 = input.LA(1);

				if ((LA34_0==COMMA))
				{
					alt34 = 1;
				}


				} finally { DebugExitDecision(34); }
				switch ( alt34 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:254:20: COMMA field
					{
					DebugLocation(254, 20);
					COMMA149=(IToken)Match(input,COMMA,Follow._COMMA_in_fieldlist1907); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_COMMA.Add(COMMA149);

					DebugLocation(254, 26);
					PushFollow(Follow._field_in_fieldlist1909);
					field150=field();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_field.Add(field150.Tree);

					}
					break;

				default:
					goto loop34;
				}
			}

			loop34:
				;

			} finally { DebugExitSubRule(34); }



			{
			// AST REWRITE
			// elements: field, field
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 254:34: -> ^( FIELDLIST field ( field )* )
			{
				DebugLocation(254, 37);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:254:37: ^( FIELDLIST field ( field )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(254, 39);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(FIELDLIST, "FIELDLIST"), root_1);

				DebugLocation(254, 49);
				adaptor.AddChild(root_1, stream_field.NextTree());
				DebugLocation(254, 55);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:254:55: ( field )*
				while ( stream_field.HasNext )
				{
					DebugLocation(254, 56);
					adaptor.AddChild(root_1, stream_field.NextTree());

				}
				stream_field.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("fieldlist", 34);
			LeaveRule("fieldlist", 34);
			LeaveRule_fieldlist();
		}
		DebugLocation(254, 63);
		} finally { DebugExitRule(GrammarFileName, "fieldlist"); }
		return retval;

	}
	// $ANTLR end "fieldlist"

	partial void EnterRule_field();
	partial void LeaveRule_field();

	// $ANTLR start "field"
	// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:256:1: field : ID EQ exp -> ^( FIELD ID exp ) ;
	[GrammarRule("field")]
	private AstParserRuleReturnScope<object, IToken> field()
	{
		EnterRule_field();
		EnterRule("field", 35);
		TraceIn("field", 35);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID151 = default(IToken);
		IToken EQ152 = default(IToken);
		AstParserRuleReturnScope<object, IToken> exp153 = default(AstParserRuleReturnScope<object, IToken>);

		object ID151_tree = default(object);
		object EQ152_tree = default(object);
		RewriteRuleITokenStream stream_EQ=new RewriteRuleITokenStream(adaptor,"token EQ");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleSubtreeStream stream_exp=new RewriteRuleSubtreeStream(adaptor,"rule exp");
		try { DebugEnterRule(GrammarFileName, "field");
		DebugLocation(256, 36);
		try
		{
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:256:7: ( ID EQ exp -> ^( FIELD ID exp ) )
			DebugEnterAlt(1);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:256:9: ID EQ exp
			{
			DebugLocation(256, 9);
			ID151=(IToken)Match(input,ID,Follow._ID_in_field1932); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(ID151);

			DebugLocation(256, 12);
			EQ152=(IToken)Match(input,EQ,Follow._EQ_in_field1934); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_EQ.Add(EQ152);

			DebugLocation(256, 15);
			PushFollow(Follow._exp_in_field1936);
			exp153=exp();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_exp.Add(exp153.Tree);


			{
			// AST REWRITE
			// elements: ID, exp
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 256:19: -> ^( FIELD ID exp )
			{
				DebugLocation(256, 22);
				// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:256:22: ^( FIELD ID exp )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(256, 24);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(FIELD, "FIELD"), root_1);

				DebugLocation(256, 30);
				adaptor.AddChild(root_1, stream_ID.NextNode());
				DebugLocation(256, 33);
				adaptor.AddChild(root_1, stream_exp.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("field", 35);
			LeaveRule("field", 35);
			LeaveRule_field();
		}
		DebugLocation(256, 36);
		} finally { DebugExitRule(GrammarFileName, "field"); }
		return retval;

	}
	// $ANTLR end "field"

	partial void EnterRule_synpred1_tiger_fragment();
	partial void LeaveRule_synpred1_tiger_fragment();

	// $ANTLR start synpred1_tiger
	public void synpred1_tiger_fragment()
	{
		EnterRule_synpred1_tiger_fragment();
		EnterRule("synpred1_tiger_fragment", 36);
		TraceIn("synpred1_tiger_fragment", 36);
		try
		{
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:154:15: ( OR auxOR )
			DebugEnterAlt(1);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:154:15: OR auxOR
			{
			DebugLocation(154, 15);
			Match(input,OR,Follow._OR_in_synpred1_tiger824); if (state.failed) return;
			DebugLocation(154, 20);
			PushFollow(Follow._auxOR_in_synpred1_tiger828);
			auxOR();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred1_tiger_fragment", 36);
			LeaveRule("synpred1_tiger_fragment", 36);
			LeaveRule_synpred1_tiger_fragment();
		}
	}
	// $ANTLR end synpred1_tiger

	partial void EnterRule_synpred2_tiger_fragment();
	partial void LeaveRule_synpred2_tiger_fragment();

	// $ANTLR start synpred2_tiger
	public void synpred2_tiger_fragment()
	{
		EnterRule_synpred2_tiger_fragment();
		EnterRule("synpred2_tiger_fragment", 37);
		TraceIn("synpred2_tiger_fragment", 37);
		try
		{
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:156:17: ( AND auxAND )
			DebugEnterAlt(1);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:156:17: AND auxAND
			{
			DebugLocation(156, 17);
			Match(input,AND,Follow._AND_in_synpred2_tiger844); if (state.failed) return;
			DebugLocation(156, 22);
			PushFollow(Follow._auxAND_in_synpred2_tiger847);
			auxAND();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred2_tiger_fragment", 37);
			LeaveRule("synpred2_tiger_fragment", 37);
			LeaveRule_synpred2_tiger_fragment();
		}
	}
	// $ANTLR end synpred2_tiger

	partial void EnterRule_synpred3_tiger_fragment();
	partial void LeaveRule_synpred3_tiger_fragment();

	// $ANTLR start synpred3_tiger
	public void synpred3_tiger_fragment()
	{
		EnterRule_synpred3_tiger_fragment();
		EnterRule("synpred3_tiger_fragment", 38);
		TraceIn("synpred3_tiger_fragment", 38);
		try
		{
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:158:17: ( ( EQ auxPM ) )
			DebugEnterAlt(1);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:158:17: ( EQ auxPM )
			{
			DebugLocation(158, 17);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:158:17: ( EQ auxPM )
			DebugEnterAlt(1);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:158:18: EQ auxPM
			{
			DebugLocation(158, 18);
			Match(input,EQ,Follow._EQ_in_synpred3_tiger862); if (state.failed) return;
			DebugLocation(158, 22);
			PushFollow(Follow._auxPM_in_synpred3_tiger865);
			auxPM();
			PopFollow();
			if (state.failed) return;

			}


			}

		}
		finally
		{
			TraceOut("synpred3_tiger_fragment", 38);
			LeaveRule("synpred3_tiger_fragment", 38);
			LeaveRule_synpred3_tiger_fragment();
		}
	}
	// $ANTLR end synpred3_tiger

	partial void EnterRule_synpred4_tiger_fragment();
	partial void LeaveRule_synpred4_tiger_fragment();

	// $ANTLR start synpred4_tiger
	public void synpred4_tiger_fragment()
	{
		EnterRule_synpred4_tiger_fragment();
		EnterRule("synpred4_tiger_fragment", 39);
		TraceIn("synpred4_tiger_fragment", 39);
		try
		{
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:158:31: ( ( NOTEQ auxPM ) )
			DebugEnterAlt(1);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:158:31: ( NOTEQ auxPM )
			{
			DebugLocation(158, 31);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:158:31: ( NOTEQ auxPM )
			DebugEnterAlt(1);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:158:32: NOTEQ auxPM
			{
			DebugLocation(158, 32);
			Match(input,NOTEQ,Follow._NOTEQ_in_synpred4_tiger871); if (state.failed) return;
			DebugLocation(158, 39);
			PushFollow(Follow._auxPM_in_synpred4_tiger874);
			auxPM();
			PopFollow();
			if (state.failed) return;

			}


			}

		}
		finally
		{
			TraceOut("synpred4_tiger_fragment", 39);
			LeaveRule("synpred4_tiger_fragment", 39);
			LeaveRule_synpred4_tiger_fragment();
		}
	}
	// $ANTLR end synpred4_tiger

	partial void EnterRule_synpred5_tiger_fragment();
	partial void LeaveRule_synpred5_tiger_fragment();

	// $ANTLR start synpred5_tiger
	public void synpred5_tiger_fragment()
	{
		EnterRule_synpred5_tiger_fragment();
		EnterRule("synpred5_tiger_fragment", 40);
		TraceIn("synpred5_tiger_fragment", 40);
		try
		{
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:158:48: ( ( LTEQ auxPM ) )
			DebugEnterAlt(1);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:158:48: ( LTEQ auxPM )
			{
			DebugLocation(158, 48);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:158:48: ( LTEQ auxPM )
			DebugEnterAlt(1);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:158:49: LTEQ auxPM
			{
			DebugLocation(158, 49);
			Match(input,LTEQ,Follow._LTEQ_in_synpred5_tiger880); if (state.failed) return;
			DebugLocation(158, 55);
			PushFollow(Follow._auxPM_in_synpred5_tiger883);
			auxPM();
			PopFollow();
			if (state.failed) return;

			}


			}

		}
		finally
		{
			TraceOut("synpred5_tiger_fragment", 40);
			LeaveRule("synpred5_tiger_fragment", 40);
			LeaveRule_synpred5_tiger_fragment();
		}
	}
	// $ANTLR end synpred5_tiger

	partial void EnterRule_synpred6_tiger_fragment();
	partial void LeaveRule_synpred6_tiger_fragment();

	// $ANTLR start synpred6_tiger
	public void synpred6_tiger_fragment()
	{
		EnterRule_synpred6_tiger_fragment();
		EnterRule("synpred6_tiger_fragment", 41);
		TraceIn("synpred6_tiger_fragment", 41);
		try
		{
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:158:64: ( ( GTEQ auxPM ) )
			DebugEnterAlt(1);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:158:64: ( GTEQ auxPM )
			{
			DebugLocation(158, 64);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:158:64: ( GTEQ auxPM )
			DebugEnterAlt(1);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:158:65: GTEQ auxPM
			{
			DebugLocation(158, 65);
			Match(input,GTEQ,Follow._GTEQ_in_synpred6_tiger889); if (state.failed) return;
			DebugLocation(158, 71);
			PushFollow(Follow._auxPM_in_synpred6_tiger892);
			auxPM();
			PopFollow();
			if (state.failed) return;

			}


			}

		}
		finally
		{
			TraceOut("synpred6_tiger_fragment", 41);
			LeaveRule("synpred6_tiger_fragment", 41);
			LeaveRule_synpred6_tiger_fragment();
		}
	}
	// $ANTLR end synpred6_tiger

	partial void EnterRule_synpred7_tiger_fragment();
	partial void LeaveRule_synpred7_tiger_fragment();

	// $ANTLR start synpred7_tiger
	public void synpred7_tiger_fragment()
	{
		EnterRule_synpred7_tiger_fragment();
		EnterRule("synpred7_tiger_fragment", 42);
		TraceIn("synpred7_tiger_fragment", 42);
		try
		{
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:158:80: ( ( LT auxPM ) )
			DebugEnterAlt(1);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:158:80: ( LT auxPM )
			{
			DebugLocation(158, 80);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:158:80: ( LT auxPM )
			DebugEnterAlt(1);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:158:81: LT auxPM
			{
			DebugLocation(158, 81);
			Match(input,LT,Follow._LT_in_synpred7_tiger898); if (state.failed) return;
			DebugLocation(158, 85);
			PushFollow(Follow._auxPM_in_synpred7_tiger901);
			auxPM();
			PopFollow();
			if (state.failed) return;

			}


			}

		}
		finally
		{
			TraceOut("synpred7_tiger_fragment", 42);
			LeaveRule("synpred7_tiger_fragment", 42);
			LeaveRule_synpred7_tiger_fragment();
		}
	}
	// $ANTLR end synpred7_tiger

	partial void EnterRule_synpred8_tiger_fragment();
	partial void LeaveRule_synpred8_tiger_fragment();

	// $ANTLR start synpred8_tiger
	public void synpred8_tiger_fragment()
	{
		EnterRule_synpred8_tiger_fragment();
		EnterRule("synpred8_tiger_fragment", 43);
		TraceIn("synpred8_tiger_fragment", 43);
		try
		{
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:158:94: ( ( GT auxPM ) )
			DebugEnterAlt(1);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:158:94: ( GT auxPM )
			{
			DebugLocation(158, 94);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:158:94: ( GT auxPM )
			DebugEnterAlt(1);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:158:95: GT auxPM
			{
			DebugLocation(158, 95);
			Match(input,GT,Follow._GT_in_synpred8_tiger907); if (state.failed) return;
			DebugLocation(158, 99);
			PushFollow(Follow._auxPM_in_synpred8_tiger910);
			auxPM();
			PopFollow();
			if (state.failed) return;

			}


			}

		}
		finally
		{
			TraceOut("synpred8_tiger_fragment", 43);
			LeaveRule("synpred8_tiger_fragment", 43);
			LeaveRule_synpred8_tiger_fragment();
		}
	}
	// $ANTLR end synpred8_tiger

	partial void EnterRule_synpred9_tiger_fragment();
	partial void LeaveRule_synpred9_tiger_fragment();

	// $ANTLR start synpred9_tiger
	public void synpred9_tiger_fragment()
	{
		EnterRule_synpred9_tiger_fragment();
		EnterRule("synpred9_tiger_fragment", 44);
		TraceIn("synpred9_tiger_fragment", 44);
		try
		{
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:160:16: ( ( PLUS auxMD ) )
			DebugEnterAlt(1);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:160:16: ( PLUS auxMD )
			{
			DebugLocation(160, 16);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:160:16: ( PLUS auxMD )
			DebugEnterAlt(1);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:160:17: PLUS auxMD
			{
			DebugLocation(160, 17);
			Match(input,PLUS,Follow._PLUS_in_synpred9_tiger926); if (state.failed) return;
			DebugLocation(160, 23);
			PushFollow(Follow._auxMD_in_synpred9_tiger929);
			auxMD();
			PopFollow();
			if (state.failed) return;

			}


			}

		}
		finally
		{
			TraceOut("synpred9_tiger_fragment", 44);
			LeaveRule("synpred9_tiger_fragment", 44);
			LeaveRule_synpred9_tiger_fragment();
		}
	}
	// $ANTLR end synpred9_tiger

	partial void EnterRule_synpred10_tiger_fragment();
	partial void LeaveRule_synpred10_tiger_fragment();

	// $ANTLR start synpred10_tiger
	public void synpred10_tiger_fragment()
	{
		EnterRule_synpred10_tiger_fragment();
		EnterRule("synpred10_tiger_fragment", 45);
		TraceIn("synpred10_tiger_fragment", 45);
		try
		{
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:160:32: ( ( MINUS auxMD ) )
			DebugEnterAlt(1);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:160:32: ( MINUS auxMD )
			{
			DebugLocation(160, 32);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:160:32: ( MINUS auxMD )
			DebugEnterAlt(1);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:160:33: MINUS auxMD
			{
			DebugLocation(160, 33);
			Match(input,MINUS,Follow._MINUS_in_synpred10_tiger935); if (state.failed) return;
			DebugLocation(160, 40);
			PushFollow(Follow._auxMD_in_synpred10_tiger938);
			auxMD();
			PopFollow();
			if (state.failed) return;

			}


			}

		}
		finally
		{
			TraceOut("synpred10_tiger_fragment", 45);
			LeaveRule("synpred10_tiger_fragment", 45);
			LeaveRule_synpred10_tiger_fragment();
		}
	}
	// $ANTLR end synpred10_tiger

	partial void EnterRule_synpred11_tiger_fragment();
	partial void LeaveRule_synpred11_tiger_fragment();

	// $ANTLR start synpred11_tiger
	public void synpred11_tiger_fragment()
	{
		EnterRule_synpred11_tiger_fragment();
		EnterRule("synpred11_tiger_fragment", 46);
		TraceIn("synpred11_tiger_fragment", 46);
		try
		{
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:162:17: ( ( MULT auxEXP ) )
			DebugEnterAlt(1);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:162:17: ( MULT auxEXP )
			{
			DebugLocation(162, 17);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:162:17: ( MULT auxEXP )
			DebugEnterAlt(1);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:162:18: MULT auxEXP
			{
			DebugLocation(162, 18);
			Match(input,MULT,Follow._MULT_in_synpred11_tiger953); if (state.failed) return;
			DebugLocation(162, 24);
			PushFollow(Follow._auxEXP_in_synpred11_tiger956);
			auxEXP();
			PopFollow();
			if (state.failed) return;

			}


			}

		}
		finally
		{
			TraceOut("synpred11_tiger_fragment", 46);
			LeaveRule("synpred11_tiger_fragment", 46);
			LeaveRule_synpred11_tiger_fragment();
		}
	}
	// $ANTLR end synpred11_tiger

	partial void EnterRule_synpred12_tiger_fragment();
	partial void LeaveRule_synpred12_tiger_fragment();

	// $ANTLR start synpred12_tiger
	public void synpred12_tiger_fragment()
	{
		EnterRule_synpred12_tiger_fragment();
		EnterRule("synpred12_tiger_fragment", 47);
		TraceIn("synpred12_tiger_fragment", 47);
		try
		{
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:162:34: ( ( DIV auxEXP ) )
			DebugEnterAlt(1);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:162:34: ( DIV auxEXP )
			{
			DebugLocation(162, 34);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:162:34: ( DIV auxEXP )
			DebugEnterAlt(1);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:162:35: DIV auxEXP
			{
			DebugLocation(162, 35);
			Match(input,DIV,Follow._DIV_in_synpred12_tiger962); if (state.failed) return;
			DebugLocation(162, 40);
			PushFollow(Follow._auxEXP_in_synpred12_tiger965);
			auxEXP();
			PopFollow();
			if (state.failed) return;

			}


			}

		}
		finally
		{
			TraceOut("synpred12_tiger_fragment", 47);
			LeaveRule("synpred12_tiger_fragment", 47);
			LeaveRule_synpred12_tiger_fragment();
		}
	}
	// $ANTLR end synpred12_tiger

	partial void EnterRule_synpred18_tiger_fragment();
	partial void LeaveRule_synpred18_tiger_fragment();

	// $ANTLR start synpred18_tiger
	public void synpred18_tiger_fragment()
	{
		EnterRule_synpred18_tiger_fragment();
		EnterRule("synpred18_tiger_fragment", 53);
		TraceIn("synpred18_tiger_fragment", 53);
		try
		{
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:170:8: ( right )
			DebugEnterAlt(1);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:170:8: right
			{
			DebugLocation(170, 8);
			PushFollow(Follow._right_in_synpred18_tiger1040);
			right();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred18_tiger_fragment", 53);
			LeaveRule("synpred18_tiger_fragment", 53);
			LeaveRule_synpred18_tiger_fragment();
		}
	}
	// $ANTLR end synpred18_tiger

	partial void EnterRule_synpred26_tiger_fragment();
	partial void LeaveRule_synpred26_tiger_fragment();

	// $ANTLR start synpred26_tiger
	public void synpred26_tiger_fragment()
	{
		EnterRule_synpred26_tiger_fragment();
		EnterRule("synpred26_tiger_fragment", 61);
		TraceIn("synpred26_tiger_fragment", 61);
		try
		{
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:179:7: ( array )
			DebugEnterAlt(1);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:179:7: array
			{
			DebugLocation(179, 7);
			PushFollow(Follow._array_in_synpred26_tiger1135);
			array();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred26_tiger_fragment", 61);
			LeaveRule("synpred26_tiger_fragment", 61);
			LeaveRule_synpred26_tiger_fragment();
		}
	}
	// $ANTLR end synpred26_tiger

	partial void EnterRule_synpred35_tiger_fragment();
	partial void LeaveRule_synpred35_tiger_fragment();

	// $ANTLR start synpred35_tiger
	public void synpred35_tiger_fragment()
	{
		EnterRule_synpred35_tiger_fragment();
		EnterRule("synpred35_tiger_fragment", 70);
		TraceIn("synpred35_tiger_fragment", 70);
		try
		{
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:193:18: ( typedec )
			DebugEnterAlt(1);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:193:18: typedec
			{
			DebugLocation(193, 18);
			PushFollow(Follow._typedec_in_synpred35_tiger1295);
			typedec();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred35_tiger_fragment", 70);
			LeaveRule("synpred35_tiger_fragment", 70);
			LeaveRule_synpred35_tiger_fragment();
		}
	}
	// $ANTLR end synpred35_tiger

	partial void EnterRule_synpred36_tiger_fragment();
	partial void LeaveRule_synpred36_tiger_fragment();

	// $ANTLR start synpred36_tiger
	public void synpred36_tiger_fragment()
	{
		EnterRule_synpred36_tiger_fragment();
		EnterRule("synpred36_tiger_fragment", 71);
		TraceIn("synpred36_tiger_fragment", 71);
		try
		{
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:195:17: ( vardec )
			DebugEnterAlt(1);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:195:17: vardec
			{
			DebugLocation(195, 17);
			PushFollow(Follow._vardec_in_synpred36_tiger1313);
			vardec();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred36_tiger_fragment", 71);
			LeaveRule("synpred36_tiger_fragment", 71);
			LeaveRule_synpred36_tiger_fragment();
		}
	}
	// $ANTLR end synpred36_tiger

	partial void EnterRule_synpred37_tiger_fragment();
	partial void LeaveRule_synpred37_tiger_fragment();

	// $ANTLR start synpred37_tiger
	public void synpred37_tiger_fragment()
	{
		EnterRule_synpred37_tiger_fragment();
		EnterRule("synpred37_tiger_fragment", 72);
		TraceIn("synpred37_tiger_fragment", 72);
		try
		{
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:197:18: ( funcdec )
			DebugEnterAlt(1);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:197:18: funcdec
			{
			DebugLocation(197, 18);
			PushFollow(Follow._funcdec_in_synpred37_tiger1332);
			funcdec();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred37_tiger_fragment", 72);
			LeaveRule("synpred37_tiger_fragment", 72);
			LeaveRule_synpred37_tiger_fragment();
		}
	}
	// $ANTLR end synpred37_tiger

	partial void EnterRule_synpred48_tiger_fragment();
	partial void LeaveRule_synpred48_tiger_fragment();

	// $ANTLR start synpred48_tiger
	public void synpred48_tiger_fragment()
	{
		EnterRule_synpred48_tiger_fragment();
		EnterRule("synpred48_tiger_fragment", 83);
		TraceIn("synpred48_tiger_fragment", 83);
		try
		{
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:226:28: ( ELSE exp )
			DebugEnterAlt(1);
			// C:\\Users\\Yanesita&Machy\\Desktop\\TIGER-YanetFrancisco(C412)-FabiolaBecerra(C411)\\CODIGO\\TigerCompiler\\TigerCompiler\\Grammar\\tiger.g:226:28: ELSE exp
			{
			DebugLocation(226, 28);
			Match(input,ELSE,Follow._ELSE_in_synpred48_tiger1661); if (state.failed) return;
			DebugLocation(226, 33);
			PushFollow(Follow._exp_in_synpred48_tiger1663);
			exp();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred48_tiger_fragment", 83);
			LeaveRule("synpred48_tiger_fragment", 83);
			LeaveRule_synpred48_tiger_fragment();
		}
	}
	// $ANTLR end synpred48_tiger
	#endregion Rules

	#region Synpreds
	private bool EvaluatePredicate(System.Action fragment)
	{
		bool success = false;
		state.backtracking++;
		try { DebugBeginBacktrack(state.backtracking);
		int start = input.Mark();
		try
		{
			fragment();
		}
		catch ( RecognitionException re )
		{
			System.Console.Error.WriteLine("impossible: "+re);
		}
		success = !state.failed;
		input.Rewind(start);
		} finally { DebugEndBacktrack(state.backtracking, success); }
		state.backtracking--;
		state.failed=false;
		return success;
	}
	#endregion Synpreds


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _exp_in_program809 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _EOF_in_program811 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _auxOR_in_exp820 = new BitSet(new ulong[]{0x1000000000000002UL});
		public static readonly BitSet _OR_in_exp824 = new BitSet(new ulong[]{0x824D40800002000UL,0x10010UL});
		public static readonly BitSet _auxOR_in_exp828 = new BitSet(new ulong[]{0x1000000000000002UL});
		public static readonly BitSet _auxAND_in_auxOR841 = new BitSet(new ulong[]{0x42UL});
		public static readonly BitSet _AND_in_auxOR844 = new BitSet(new ulong[]{0x824D40800002000UL,0x10010UL});
		public static readonly BitSet _auxAND_in_auxOR847 = new BitSet(new ulong[]{0x42UL});
		public static readonly BitSet _auxPM_in_auxAND858 = new BitSet(new ulong[]{0x43018020000002UL});
		public static readonly BitSet _EQ_in_auxAND862 = new BitSet(new ulong[]{0x824D40800002000UL,0x10010UL});
		public static readonly BitSet _auxPM_in_auxAND865 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NOTEQ_in_auxAND871 = new BitSet(new ulong[]{0x824D40800002000UL,0x10010UL});
		public static readonly BitSet _auxPM_in_auxAND874 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LTEQ_in_auxAND880 = new BitSet(new ulong[]{0x824D40800002000UL,0x10010UL});
		public static readonly BitSet _auxPM_in_auxAND883 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _GTEQ_in_auxAND889 = new BitSet(new ulong[]{0x824D40800002000UL,0x10010UL});
		public static readonly BitSet _auxPM_in_auxAND892 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LT_in_auxAND898 = new BitSet(new ulong[]{0x824D40800002000UL,0x10010UL});
		public static readonly BitSet _auxPM_in_auxAND901 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _GT_in_auxAND907 = new BitSet(new ulong[]{0x824D40800002000UL,0x10010UL});
		public static readonly BitSet _auxPM_in_auxAND910 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _auxMD_in_auxPM922 = new BitSet(new ulong[]{0x2004000000000002UL});
		public static readonly BitSet _PLUS_in_auxPM926 = new BitSet(new ulong[]{0x824D40800002000UL,0x10010UL});
		public static readonly BitSet _auxMD_in_auxPM929 = new BitSet(new ulong[]{0x2004000000000002UL});
		public static readonly BitSet _MINUS_in_auxPM935 = new BitSet(new ulong[]{0x824D40800002000UL,0x10010UL});
		public static readonly BitSet _auxMD_in_auxPM938 = new BitSet(new ulong[]{0x2004000000000002UL});
		public static readonly BitSet _auxEXP_in_auxMD949 = new BitSet(new ulong[]{0x8000000800002UL});
		public static readonly BitSet _MULT_in_auxMD953 = new BitSet(new ulong[]{0x824D40800002000UL,0x10010UL});
		public static readonly BitSet _auxEXP_in_auxMD956 = new BitSet(new ulong[]{0x8000000800002UL});
		public static readonly BitSet _DIV_in_auxMD962 = new BitSet(new ulong[]{0x824D40800002000UL,0x10010UL});
		public static readonly BitSet _auxEXP_in_auxMD965 = new BitSet(new ulong[]{0x8000000800002UL});
		public static readonly BitSet _STRING_in_auxEXP982 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _MINUS_in_auxEXP992 = new BitSet(new ulong[]{0x824D40800002000UL,0x10010UL});
		public static readonly BitSet _auxEXP_in_auxEXP994 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INT_in_auxEXP1008 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NIL_in_auxEXP1018 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _BREAK_in_auxEXP1028 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_auxEXP1038 = new BitSet(new ulong[]{0xC80000002000400UL});
		public static readonly BitSet _right_in_auxEXP1040 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ifthen_in_auxEXP1057 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _while_in_auxEXP1068 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _for_in_auxEXP1078 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _let_in_auxEXP1088 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OPAR_in_auxEXP1098 = new BitSet(new ulong[]{0x824D40800102000UL,0x10010UL});
		public static readonly BitSet _expseq_in_auxEXP1100 = new BitSet(new ulong[]{0x100000UL});
		public static readonly BitSet _CPAR_in_auxEXP1103 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _record_in_right1122 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _array_in_right1135 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _call_in_right1148 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _lvalue_in_right1160 = new BitSet(new ulong[]{0x402UL});
		public static readonly BitSet _assign_in_right1163 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OBRACK_in_array1185 = new BitSet(new ulong[]{0x824D40800002000UL,0x10010UL});
		public static readonly BitSet _exp_in_array1187 = new BitSet(new ulong[]{0x8000UL});
		public static readonly BitSet _CBRACK_in_array1189 = new BitSet(new ulong[]{0x200000000000000UL});
		public static readonly BitSet _OF_in_array1191 = new BitSet(new ulong[]{0x824D40800002000UL,0x10010UL});
		public static readonly BitSet _exp_in_array1193 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OKEYS_in_record1211 = new BitSet(new ulong[]{0x40000010000UL});
		public static readonly BitSet _fieldlist_in_record1213 = new BitSet(new ulong[]{0x10000UL});
		public static readonly BitSet _CKEYS_in_record1216 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LET_in_let1233 = new BitSet(new ulong[]{0x1000000000UL,0x5000UL});
		public static readonly BitSet _declist_in_let1235 = new BitSet(new ulong[]{0x200000000000UL});
		public static readonly BitSet _IN_in_let1237 = new BitSet(new ulong[]{0x824D40810002000UL,0x10010UL});
		public static readonly BitSet _expseq_in_let1239 = new BitSet(new ulong[]{0x10000000UL});
		public static readonly BitSet _END_in_let1242 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _declaration_in_declist1266 = new BitSet(new ulong[]{0x1000000002UL,0x5000UL});
		public static readonly BitSet _type_decl_block_in_declaration1279 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _var_decl_block_in_declaration1283 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _func_decl_block_in_declaration1287 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _typedec_in_type_decl_block1295 = new BitSet(new ulong[]{0x2UL,0x1000UL});
		public static readonly BitSet _vardec_in_var_decl_block1313 = new BitSet(new ulong[]{0x2UL,0x4000UL});
		public static readonly BitSet _funcdec_in_func_decl_block1332 = new BitSet(new ulong[]{0x1000000002UL});
		public static readonly BitSet _TYPETOK_in_typedec1352 = new BitSet(new ulong[]{0x40000000000UL});
		public static readonly BitSet _ID_in_typedec1354 = new BitSet(new ulong[]{0x20000000UL});
		public static readonly BitSet _EQ_in_typedec1356 = new BitSet(new ulong[]{0x400040000000080UL,0x80UL});
		public static readonly BitSet _type_in_typedec1358 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _TYPE_in_type1379 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_type1390 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OKEYS_in_type1400 = new BitSet(new ulong[]{0x40000010000UL});
		public static readonly BitSet _typefields_in_type1402 = new BitSet(new ulong[]{0x10000UL});
		public static readonly BitSet _CKEYS_in_type1405 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ARRAY_in_type1420 = new BitSet(new ulong[]{0x200000000000000UL});
		public static readonly BitSet _OF_in_type1422 = new BitSet(new ulong[]{0x40000000000UL,0x80UL});
		public static readonly BitSet _TYPE_in_type1425 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_type1437 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FUNC_in_funcdec1454 = new BitSet(new ulong[]{0x40000000000UL});
		public static readonly BitSet _ID_in_funcdec1456 = new BitSet(new ulong[]{0x800000000000000UL});
		public static readonly BitSet _OPAR_in_funcdec1458 = new BitSet(new ulong[]{0x40000100000UL});
		public static readonly BitSet _typefields_in_funcdec1460 = new BitSet(new ulong[]{0x100000UL});
		public static readonly BitSet _CPAR_in_funcdec1463 = new BitSet(new ulong[]{0x20020000UL});
		public static readonly BitSet _procOrfunc_in_funcdec1465 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _COLON_in_procOrfunc1490 = new BitSet(new ulong[]{0x40000000000UL,0x80UL});
		public static readonly BitSet _ID_in_procOrfunc1493 = new BitSet(new ulong[]{0x20000000UL});
		public static readonly BitSet _TYPE_in_procOrfunc1497 = new BitSet(new ulong[]{0x20000000UL});
		public static readonly BitSet _EQ_in_procOrfunc1500 = new BitSet(new ulong[]{0x824D40800002000UL,0x10010UL});
		public static readonly BitSet _exp_in_procOrfunc1502 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _EQ_in_procOrfunc1522 = new BitSet(new ulong[]{0x824D40800002000UL,0x10010UL});
		public static readonly BitSet _exp_in_procOrfunc1524 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _VAR_in_vardec1542 = new BitSet(new ulong[]{0x40000000000UL});
		public static readonly BitSet _ID_in_vardec1544 = new BitSet(new ulong[]{0x20400UL});
		public static readonly BitSet _COLON_in_vardec1547 = new BitSet(new ulong[]{0x40000000000UL,0x80UL});
		public static readonly BitSet _ID_in_vardec1550 = new BitSet(new ulong[]{0x400UL});
		public static readonly BitSet _TYPE_in_vardec1554 = new BitSet(new ulong[]{0x400UL});
		public static readonly BitSet _ASSIGN_in_vardec1559 = new BitSet(new ulong[]{0x824D40800002000UL,0x10010UL});
		public static readonly BitSet _exp_in_vardec1561 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FOR_in_for1587 = new BitSet(new ulong[]{0x40000000000UL});
		public static readonly BitSet _ID_in_for1589 = new BitSet(new ulong[]{0x400UL});
		public static readonly BitSet _ASSIGN_in_for1591 = new BitSet(new ulong[]{0x824D40800002000UL,0x10010UL});
		public static readonly BitSet _exp_in_for1593 = new BitSet(new ulong[]{0x0UL,0x40UL});
		public static readonly BitSet _TO_in_for1595 = new BitSet(new ulong[]{0x824D40800002000UL,0x10010UL});
		public static readonly BitSet _exp_in_for1597 = new BitSet(new ulong[]{0x1000000UL});
		public static readonly BitSet _DO_in_for1599 = new BitSet(new ulong[]{0x824D40800002000UL,0x10010UL});
		public static readonly BitSet _exp_in_for1601 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _WHILE_in_while1625 = new BitSet(new ulong[]{0x824D40800002000UL,0x10010UL});
		public static readonly BitSet _exp_in_while1627 = new BitSet(new ulong[]{0x1000000UL});
		public static readonly BitSet _DO_in_while1629 = new BitSet(new ulong[]{0x824D40800002000UL,0x10010UL});
		public static readonly BitSet _exp_in_while1631 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IF_in_ifthen1651 = new BitSet(new ulong[]{0x824D40800002000UL,0x10010UL});
		public static readonly BitSet _exp_in_ifthen1653 = new BitSet(new ulong[]{0x0UL,0x20UL});
		public static readonly BitSet _THEN_in_ifthen1655 = new BitSet(new ulong[]{0x824D40800002000UL,0x10010UL});
		public static readonly BitSet _exp_in_ifthen1657 = new BitSet(new ulong[]{0x8000002UL});
		public static readonly BitSet _ELSE_in_ifthen1661 = new BitSet(new ulong[]{0x824D40800002000UL,0x10010UL});
		public static readonly BitSet _exp_in_ifthen1663 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OPAR_in_call1690 = new BitSet(new ulong[]{0x824D40800102000UL,0x10010UL});
		public static readonly BitSet _explist_in_call1692 = new BitSet(new ulong[]{0x100000UL});
		public static readonly BitSet _CPAR_in_call1695 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ASSIGN_in_assign1714 = new BitSet(new ulong[]{0x824D40800002000UL,0x10010UL});
		public static readonly BitSet _exp_in_assign1716 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _arrayAccess_in_lvalue1734 = new BitSet(new ulong[]{0x80000002000002UL});
		public static readonly BitSet _idAccess_in_lvalue1738 = new BitSet(new ulong[]{0x80000002000002UL});
		public static readonly BitSet _OBRACK_in_arrayAccess1750 = new BitSet(new ulong[]{0x824D40800002000UL,0x10010UL});
		public static readonly BitSet _exp_in_arrayAccess1752 = new BitSet(new ulong[]{0x8000UL});
		public static readonly BitSet _CBRACK_in_arrayAccess1754 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DOT_in_idAccess1771 = new BitSet(new ulong[]{0x40000000000UL});
		public static readonly BitSet _ID_in_idAccess1773 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _exp_in_expseq1789 = new BitSet(new ulong[]{0x2UL,0x8UL});
		public static readonly BitSet _SMCOL_in_expseq1792 = new BitSet(new ulong[]{0x824D40800002000UL,0x10010UL});
		public static readonly BitSet _exp_in_expseq1794 = new BitSet(new ulong[]{0x2UL,0x8UL});
		public static readonly BitSet _exp_in_explist1813 = new BitSet(new ulong[]{0x40002UL});
		public static readonly BitSet _COMMA_in_explist1816 = new BitSet(new ulong[]{0x824D40800002000UL,0x10010UL});
		public static readonly BitSet _exp_in_explist1818 = new BitSet(new ulong[]{0x40002UL});
		public static readonly BitSet _typefield_in_typefields1846 = new BitSet(new ulong[]{0x40002UL});
		public static readonly BitSet _COMMA_in_typefields1849 = new BitSet(new ulong[]{0x40000000000UL});
		public static readonly BitSet _typefield_in_typefields1851 = new BitSet(new ulong[]{0x40002UL});
		public static readonly BitSet _ID_in_typefield1873 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _COLON_in_typefield1875 = new BitSet(new ulong[]{0x40000000000UL,0x80UL});
		public static readonly BitSet _TYPE_in_typefield1878 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_typefield1882 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _field_in_fieldlist1904 = new BitSet(new ulong[]{0x40002UL});
		public static readonly BitSet _COMMA_in_fieldlist1907 = new BitSet(new ulong[]{0x40000000000UL});
		public static readonly BitSet _field_in_fieldlist1909 = new BitSet(new ulong[]{0x40002UL});
		public static readonly BitSet _ID_in_field1932 = new BitSet(new ulong[]{0x20000000UL});
		public static readonly BitSet _EQ_in_field1934 = new BitSet(new ulong[]{0x824D40800002000UL,0x10010UL});
		public static readonly BitSet _exp_in_field1936 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OR_in_synpred1_tiger824 = new BitSet(new ulong[]{0x824D40800002000UL,0x10010UL});
		public static readonly BitSet _auxOR_in_synpred1_tiger828 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _AND_in_synpred2_tiger844 = new BitSet(new ulong[]{0x824D40800002000UL,0x10010UL});
		public static readonly BitSet _auxAND_in_synpred2_tiger847 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _EQ_in_synpred3_tiger862 = new BitSet(new ulong[]{0x824D40800002000UL,0x10010UL});
		public static readonly BitSet _auxPM_in_synpred3_tiger865 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NOTEQ_in_synpred4_tiger871 = new BitSet(new ulong[]{0x824D40800002000UL,0x10010UL});
		public static readonly BitSet _auxPM_in_synpred4_tiger874 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LTEQ_in_synpred5_tiger880 = new BitSet(new ulong[]{0x824D40800002000UL,0x10010UL});
		public static readonly BitSet _auxPM_in_synpred5_tiger883 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _GTEQ_in_synpred6_tiger889 = new BitSet(new ulong[]{0x824D40800002000UL,0x10010UL});
		public static readonly BitSet _auxPM_in_synpred6_tiger892 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LT_in_synpred7_tiger898 = new BitSet(new ulong[]{0x824D40800002000UL,0x10010UL});
		public static readonly BitSet _auxPM_in_synpred7_tiger901 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _GT_in_synpred8_tiger907 = new BitSet(new ulong[]{0x824D40800002000UL,0x10010UL});
		public static readonly BitSet _auxPM_in_synpred8_tiger910 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _PLUS_in_synpred9_tiger926 = new BitSet(new ulong[]{0x824D40800002000UL,0x10010UL});
		public static readonly BitSet _auxMD_in_synpred9_tiger929 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _MINUS_in_synpred10_tiger935 = new BitSet(new ulong[]{0x824D40800002000UL,0x10010UL});
		public static readonly BitSet _auxMD_in_synpred10_tiger938 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _MULT_in_synpred11_tiger953 = new BitSet(new ulong[]{0x824D40800002000UL,0x10010UL});
		public static readonly BitSet _auxEXP_in_synpred11_tiger956 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DIV_in_synpred12_tiger962 = new BitSet(new ulong[]{0x824D40800002000UL,0x10010UL});
		public static readonly BitSet _auxEXP_in_synpred12_tiger965 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _right_in_synpred18_tiger1040 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _array_in_synpred26_tiger1135 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _typedec_in_synpred35_tiger1295 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _vardec_in_synpred36_tiger1313 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _funcdec_in_synpred37_tiger1332 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ELSE_in_synpred48_tiger1661 = new BitSet(new ulong[]{0x824D40800002000UL,0x10010UL});
		public static readonly BitSet _exp_in_synpred48_tiger1663 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace  TigerCompiler.Grammar 
